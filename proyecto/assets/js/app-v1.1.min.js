"use strict";

let isCopyMode = false; // Variable para rastrear el estado de copia





// Asignar la función handleKeyDown al evento keydown del documento
document.addEventListener('keydown', handleKeyDown);

    // Función para recargar la página
document.getElementById('reset').addEventListener('click', function() {
        location.reload();
      });
  

      // Función para abrir la ventana modal
function openMaterialModal() {
        document.getElementById('material-modal').style.display = 'block';
      }
    
      // Función para cerrar la ventana modal
function closeMaterialModal() {
        document.getElementById('material-modal').style.display = 'none';
      }
    
      // Cerrar la ventana modal si el usuario hace clic fuera de ella
window.onclick = function(event) {
        const modal = document.getElementById('material-modal');
        if (event.target == modal) {
          modal.style.display = 'none';
        }
      }
  


function handleKeyDown(event) {
    // Obtener el código de la tecla presionada
    const key = event.key;
    const isCtrlPressed = event.ctrlKey;

    // Verificar si la tecla presionada es "Delete" o "Backspace"
    if (key === "Delete" || key === "Backspace") {
        // Llamar a la función que deseas ejecutar
        deleteSelected();
    }
    else if (key === "a") {
        // Activar el modo de creación y desactivar el modo de selección
        creationMode = true; 
        desactivateSelectMode();
    }
    else if (key === "d") {
        // Desactivar el modo de creación
        creationMode = false;
    }
    else if (key === "r") {
        // Recargar la página
        location.reload();
    }
    else if (key === "s") {
        // Activar el modo de selección
        activateSelectMode();
    }

    else if (key === "v") {
        // Pegar la selección
        pasteSelection();
    }
    else if (isCtrlPressed && key === "c") {
        // Copiar la selección al portapapeles
        copySelection();
    }
    else if (isCtrlPressed && key === "z") {
        // Copiar la selección al portapapeles
        undo();
    }

    else if (isCtrlPressed && key === "y") {
        // Copiar la selección al portapapeles
        redo();
    }
    else if (isCtrlPressed && key === "v") {
        // Pegar la selección desde el portapapeles 
        pasteSelection();
        deactivateCopyMode(); // Desactivar el modo de copiar
        render(); // Renderizar el canvas después de pegar
        creationMode = true; 
        desactivateSelectMode();
    }
    else if (key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight") {
        // Mover la selección en el portapapeles con las teclas de flecha
        if (clipboard.selection && clipboard.selection.joints.length > 0) {
            const moveAmount = 20; // Cantidad de unidades para mover con cada flecha

            switch (key) {
                case 'ArrowUp':
                    moveClipboardSelection(0, -moveAmount);
                    break;
                case 'ArrowDown':
                    moveClipboardSelection(0, moveAmount);
                    break;
                case 'ArrowLeft':
                    moveClipboardSelection(-moveAmount, 0);
                    break;
                case 'ArrowRight':
                    moveClipboardSelection(moveAmount, 0);
                    break;
            }

            render(); // Renderizar después de mover la selección
        }
    }
}

// Asignar la función handleKeyDown al evento keydown del documento
document.addEventListener('keydown', handleKeyDown);

function deactivateCopyMode() {
    clipboard.selection = null; // Limpiar el portapapeles
    render(); // Volver a renderizar el canvas para limpiar el estado de copia
}


let canvasBackgroundImage = null;

function render() {
    // Limpiar el canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Renderizar beams
    bridgeModel.beams.forEach(beam => {
        if (beam.jointA && beam.jointB) {
            ctx.strokeStyle = selectedBeams.includes(beam) ? 'black' : '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(beam.jointA.position[0], beam.jointA.position[1]);
            ctx.lineTo(beam.jointB.position[0], beam.jointB.position[1]);
            ctx.stroke();
        } else {
            console.warn('Beam skipped in rendering because jointA or jointB is undefined:', beam);
        }
    });

    // Renderizar joints
    bridgeModel.joints.forEach(joint => {
        // Establecer el color según el tipo de joint
        switch (joint.jointType) {
            case 'f':
                renderFixedJoint1(ctx, joint);
                break;
            case 's':
                renderSlideJoint1(ctx, joint);
                break;
            default:
                renderDefaultJoint1(ctx, joint);
                break;
        }
    });

    // Renderizar selección de clipboard si existe
    if (clipboard.selection) {
        clipboard.selection.joints.forEach(joint => {
            renderDefaultJoint1(ctx, joint);
        });

        clipboard.selection.beams.forEach(beam => {
            ctx.strokeStyle = 'grey';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(beam.jointA.position[0], beam.jointA.position[1]);
            ctx.lineTo(beam.jointB.position[0], beam.jointB.position[1]);
            ctx.stroke();
        });
    }

    // Renderizar rectángulo de selección si existe
    if (selectionRect) {
        ctx.strokeStyle = '#34495e'; // Light blue for selection rectangle
        ctx.lineWidth = 1; // Line width set to 1 for selection rectangle
        ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
    }
}

// Función para renderizar un joint fijo
function renderFixedJoint1(ctx, joint) {
    ctx.fillStyle = selectedJoints.includes(joint) ? 'black' : '#34495e'; // Red for selected, red for fixed joints
    ctx.beginPath();
    for (let t = -1; t <= 1; t++) {
        ctx.moveTo(joint.position[0] + 2.5 + 5 * t, joint.position[1] + 15);
        ctx.lineTo(joint.position[0] - 2.5 + 5 * t, joint.position[1] + 20);
    }
    ctx.stroke();

    //circulo
    ctx.beginPath();
    ctx.arc(joint.position[0], joint.position[1], 8, 0, Math.PI * 2);
    ctx.fill();

   // Dibujar triángulo
   ctx.strokeStyle = joint.selected ? joint.selectedColor : joint.color;
   ctx.lineWidth = 2;
   ctx.lineCap = "round";
   ctx.beginPath();
   ctx.moveTo(joint.position[0] - 4, joint.position[1] + 15);
   ctx.lineTo(joint.position[0] + 4, joint.position[1] + 15);
   ctx.lineTo(joint.position[0], joint.position[1]);
   ctx.lineTo(joint.position[0] - 4, joint.position[1] + 15); // Para cerrar el triángulo

    // Calcular la posición horizontal central
    const middleX = joint.position[0];

    // Longitud deseada para la línea adicional
    const additionalLineLength = 20; // Ajusta esta longitud según sea necesario

    // Agregar línea adicional desde la base del triángulo
    ctx.moveTo(middleX - additionalLineLength / 2, joint.position[1] + 15);
    ctx.lineTo(middleX + additionalLineLength / 2, joint.position[1] + 15);
    
   ctx.stroke();
}

// Función para renderizar un joint deslizante
function renderSlideJoint1(ctx, joint) {
    //slide
    ctx.fillStyle = selectedJoints.includes(joint) ? 'black' : '#34495e'; // Red for selected, blue for slide joints
    ctx.beginPath();
    ctx.moveTo(joint.position[0] - 10, joint.position[1] + 20);
    ctx.lineTo(joint.position[0] + 10, joint.position[1] + 20);
    ctx.stroke();
    
    //circulo
    ctx.beginPath();
    ctx.arc(joint.position[0], joint.position[1], 8, 0, Math.PI * 2);
    ctx.fill();

    // Dibujar triángulo
    ctx.strokeStyle = joint.selected ? joint.selectedColor : joint.color;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(joint.position[0] - 5, joint.position[1] + 10);
    ctx.lineTo(joint.position[0] + 5, joint.position[1] + 10);
    ctx.lineTo(joint.position[0], joint.position[1]);
    ctx.lineTo(joint.position[0] - 5, joint.position[1] + 10); // Para cerrar el triángulo
    ctx.stroke();
}

// Función para renderizar un joint por defecto
function renderDefaultJoint1(ctx, joint) {
    ctx.fillStyle = selectedJoints.includes(joint) ? 'black' : '#34495e'; // Red for selected, dark grey for others
    ctx.beginPath();
    ctx.arc(joint.position[0], joint.position[1], 8, 0, Math.PI * 2);
    ctx.fill();
}

function desactivateSelectMode() {
    isSelectMode = false;
}

function activateSelectMode() {
    creationMode = false;
    isSelectMode = true;
}

let isSelectMode = false;
let selectionStart = null;
let selectionRect = null;

const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
let selectedJoints = [];
let selectedBeams = [];

canvas.addEventListener('mousedown', function (e) {
    if (isSelectMode) {
        selectionStart = { x: e.offsetX, y: e.offsetY };
        selectionRect = null;
    }
});

canvas.addEventListener('mousemove', function (e) {
    if (isSelectMode && selectionStart) {
        const currentX = e.offsetX;
        const currentY = e.offsetY;
        selectionRect = {
            x: Math.min(selectionStart.x, currentX),
            y: Math.min(selectionStart.y, currentY),
            width: Math.abs(currentX - selectionStart.x),
            height: Math.abs(currentY - selectionStart.y)
        };
        render();
    }
});

canvas.addEventListener('mouseup', function (e) {
    if (isSelectMode && selectionRect) {
        selectedJoints = bridgeModel.joints.filter(joint =>
            joint.position[0] >= selectionRect.x &&
            joint.position[0] <= selectionRect.x + selectionRect.width &&
            joint.position[1] >= selectionRect.y &&
            joint.position[1] <= selectionRect.y + selectionRect.height
        );
        selectedBeams = bridgeModel.beams.filter(beam =>
            (beam.jointA.position[0] >= selectionRect.x && beam.jointA.position[0] <= selectionRect.x + selectionRect.width &&
            beam.jointA.position[1] >= selectionRect.y && beam.jointA.position[1] <= selectionRect.y + selectionRect.height) &&
            (beam.jointB.position[0] >= selectionRect.x && beam.jointB.position[0] <= selectionRect.x + selectionRect.width &&
            beam.jointB.position[1] >= selectionRect.y && beam.jointB.position[1] <= selectionRect.y + selectionRect.height)
        );
        render();
        selectionStart = null;
        selectionRect = null;
    }
});


let clipboard = {
    selection: null
};

// Event listener para el botón Copy
document.getElementById('copy-button').addEventListener('click', function() {
    if (selectedJoints.length > 0 || selectedBeams.length > 0) {
        copySelection();
        clipboard.selection.joints.forEach(joint => {
            selectedJoints.push(joint);
        });
        render(); // Renderizar después de copiar la selección
    }
});

// Event listener para el botón Paste
document.getElementById('paste-button').addEventListener('click', function() {
    if (clipboard.selection) {
        pasteSelection();
        clipboard.selection = null; // Limpiar la selección del portapapeles después de pegar
        render(); // Renderizar después de pegar la selección
    }
});

// Event listener para las teclas de flecha (movimiento)
document.addEventListener('keydown', function(event) {
    if (clipboard.selection && clipboard.selection.joints.length > 0) {
        const moveAmount = 20; // Cantidad de unidades para mover con cada flecha

        switch (event.key) {
            case 'ArrowUp':
                moveClipboardSelection(0, -moveAmount);
                break;
            case 'ArrowDown':
                moveClipboardSelection(0, moveAmount);
                break;
            case 'ArrowLeft':
                moveClipboardSelection(-moveAmount, 0);
                break;
            case 'ArrowRight':
                moveClipboardSelection(moveAmount, 0);
                break;
        }

        render(); // Renderizar después de mover la selección
    }
});

// Event listeners para manejar la selección con el mouse
canvas.addEventListener('mousedown', function (e) {
    if (isSelectMode) {
        selectionStart = { x: e.offsetX, y: e.offsetY };
        selectionRect = null;
    }
});










document.addEventListener('DOMContentLoaded', function() {
    const copyButton = document.getElementById('copy-button');
    const pasteButton = document.getElementById('paste-button');

    if (copyButton && pasteButton) {
        copyButton.addEventListener('click', function() {
            if (selectedJoints.length > 0 || selectedBeams.length > 0) {
                copySelection();
            }
        });

        pasteButton.addEventListener('click', function() {
            if (clipboard.selection) {
                pasteSelection();
                render(); // Renderizar después de pegar la selección
            }
        });
    } else {
        console.error('No se encontraron los elementos "copy-button" o "paste-button".');
    }

    // Resto de tu código aquí
});

// Variables globales


// Función para copiar la selección
function copySelection() {
    isCopyMode = true;
    clipboard.selection = {
        joints: selectedJoints.map(joint => ({
            position: [joint.position[0], joint.position[1]],
            jointType: joint.jointType,
            color: joint.color
        })),
        beams: selectedBeams.map(beam => ({
            jointA: { position: [beam.jointA.position[0], beam.jointA.position[1]] },
            jointB: { position: [beam.jointB.position[0], beam.jointB.position[1]] },
            appliedLoad: beam.appliedLoad // Ajustar según tu estructura de datos para vigas
        }))
    };
    renderClipboardSelection();     
}

// Función para pegar la selección
function pasteSelection() {
    const offsetX = 0; 
    const offsetY = 0; 

    // Mapa para referenciar nuevos joints
    const newJointsMap = new Map();

    // Crear nuevos joints y mapear sus posiciones originales a los nuevos joints
    clipboard.selection.joints.forEach(joint => {
        const newJoint = new Joint(renderEngine); // Crear instancia de Joint
        newJoint.position = [joint.position[0] + offsetX, joint.position[1] + offsetY];
        newJoint.jointType = joint.jointType;
        newJoint.color = joint.color;
        
        bridgeModel.joints.push(newJoint); // Agregar al modelo de puente
        newJointsMap.set(joint.position.toString(), newJoint);
    });

    // Crear nuevas beams referenciando los nuevos joints
    clipboard.selection.beams.forEach(beam => {
        const jointA = newJointsMap.get(beam.jointA.position.toString());
        const jointB = newJointsMap.get(beam.jointB.position.toString());

        if (jointA && jointB) {
            const newBeam = new Beam(jointA, jointB); // Crear instancia de Beam
            newBeam.appliedLoad = beam.appliedLoad;
            
            bridgeModel.beams.push(newBeam); // Agregar al modelo de puente
        }
    });

    deactivateCopyMode(); // Desactivar modo copiar después de pegar
    render(); // Renderizar después de pegar la selección
}

// Función para mover la selección del portapapeles
function moveClipboardSelection(dx, dy) {
    clipboard.selection.joints.forEach(joint => {
        joint.position[0] += dx;
        joint.position[1] += dy;
    });

    clipboard.selection.beams.forEach(beam => {
        beam.jointA.position[0] += dx;
        beam.jointA.position[1] += dy;
        beam.jointB.position[0] += dx;
        beam.jointB.position[1] += dy;
    });
    renderClipboardSelection();
}

// Función para renderizar la selección del portapapeles
function renderClipboardSelection() {
    // Renderizar el puente existente
    render();

    // Renderizar la selección del portapapeles como un "fantasma"
    if (clipboard.selection) {
        // Renderizar nodos del portapapeles
        clipboard.selection.joints.forEach(joint => {
            ctx.fillStyle = 'rgba(52, 73, 94, 0.5)'; // Color semitransparente
            ctx.beginPath();
            ctx.arc(joint.position[0], joint.position[1], 8, 0, Math.PI * 2);
            ctx.fill();
        });

        // Renderizar vigas del portapapeles
        clipboard.selection.beams.forEach(beam => {
            const jointA = clipboard.selection.joints.find(joint => joint.position.toString() === beam.jointA.position.toString());
            const jointB = clipboard.selection.joints.find(joint => joint.position.toString() === beam.jointB.position.toString());

            if (jointA && jointB) {
                ctx.strokeStyle = 'rgba(52, 73, 94, 0.5)'; // Color semitransparente
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(jointA.position[0], jointA.position[1]);
                ctx.lineTo(jointB.position[0], jointB.position[1]);
                ctx.stroke();
            }
        });
    }
}

// Función para desactivar el modo de copia
function deactivateCopyMode() {
    clipboard.selection = null; // Limpiar el portapapeles
    isCopyMode = false; // Desactivar el modo de copia
    render(); // Volver a renderizar el canvas para limpiar el estado de copia
}





// Event listener para las teclas de flecha (movimiento)
document.addEventListener('keydown', function(event) {
    if (isSelectMode && !isCopyMode &&  (selectedJoints.length > 0 || selectedBeams.length > 0)) {
        const moveAmount = 20; // Cantidad de unidades para mover con cada flecha

        switch (event.key) {
            case 'ArrowUp':
                moveSelection(0, -moveAmount);
                break;
            case 'ArrowDown':
                moveSelection(0, moveAmount);
                break;
            case 'ArrowLeft':
                moveSelection(-moveAmount, 0);
                break;
            case 'ArrowRight':
                moveSelection(moveAmount, 0);
                break;
        }

        render(); // Renderizar después de mover la selección
    }
});
function moveSelection(dx, dy) {
    selectedJoints.forEach(joint => {
        joint.position[0] += dx;
        joint.position[1] += dy;
    })};




function deleteSelected() {
    bridgeModel.joints = bridgeModel.joints.filter(joint => !selectedJoints.includes(joint));
    bridgeModel.beams = bridgeModel.beams.filter(beam => !selectedBeams.includes(beam));



    const jointsToRemove = [...selectedJoints];
    const beamsToRemove = [...selectedBeams];

    // Eliminar juntas
    selectedJoints.forEach(joint => {
        const index = bridgeModel.joints.indexOf(joint);
        if (index > -1) {
            bridgeModel.joints.splice(index, 1);
        }
    });

    // Eliminar vigas
    selectedBeams.forEach(beam => {
        const index = bridgeModel.beams.indexOf(beam);
        if (index > -1) {
            bridgeModel.beams.splice(index, 1);
        }
    });

    history.addActionToHistory(new RemoveSelectionAction(jointsToRemove, beamsToRemove));
    selectedJoints = [];
    selectedBeams = [];
    render();

}

document.addEventListener("keydown", handleKeyDown);


const gridSize = 20; // Tamaño de la cuadrícula
const mainArea = document.getElementById('main-canvas');
const toggleGridButton = document.getElementById('toggleGridButton');
let isGridActive = true;

if (mainArea && toggleGridButton) {
  // Alternar la visibilidad de la cuadrícula
  toggleGridButton.addEventListener('click', function() {
    isGridActive = !isGridActive;
    this.textContent = isGridActive ? 'Desactivate' : 'Activate';
    mainArea.classList.toggle('no-grid', !isGridActive);
  });
  
}

  // Función para ajustar las coordenadas a la cuadrícula
function snapToGrid(x, y, gridSize) {
    return [Math.round(x / gridSize) * gridSize, Math.round(y / gridSize) * gridSize];
  }






class Joint {
    constructor(e) {
        this.engine = e, 
        this.position = [0, 0];
        this.moving = !1;
        this.selected = !1;
        this.stillRadius = 8;
        this.motionRadius = 12;
        this.color = "#34495e";
        this.selectedColor = "#FF0000";
        this.baseLength = 10;
        this.jointType = null;
        this.applyForce = 0;
        this.force = 0;
        this.positionLock = {
            x: !1,
            y: !1
        };
        this.draggable = !0;
        this.showPosition = !0;
        this.positionLabel = null;
        this.mirrorJoint = null;

    
    }

    

    updatePosition(e, {ignoreLock: t=!1, ignoreMirror: i=!1}={}) {
        !t && this.positionLock.x || (this.position[0] = e[0]),
        !t && this.positionLock.y || (this.position[1] = e[1]);
        let o = this.engine.translateToCartesianPosition(this.position);
        // elimino esto para coords: this.positionLabel = [+o[0].toFixed(2), +o[1].toFixed(2)].join(", ")
        !i && this.mirrorJoint && this.mirrorJoint.updatePosition(this.getMirroredPosition(), {
            ignoreLock: !0,
            ignoreMirror: !0
        })
    }
    getMirroredPosition() {
        return [2 * this.engine.mirrorX - this.position[0], this.position[1]];
    }
    render(e) {
        var t = this.moving ? this.motionRadius : this.stillRadius;
        e.lineWidth = 0,
        e.fillStyle = this.selected ? this.selectedColor : this.color,
        e.beginPath(),
        e.arc(this.position[0], this.position[1], t, 0, 2 * Math.PI),
        e.fill(),
        this.showPosition && this.positionLabel && (e.textAlign = "center",
        e.fillText(this.positionLabel, this.position[0], this.position[1] - 14)),
        this.jointType && ("f" == this.jointType ? this.renderFixedJoint(e) : "s" == this.jointType && this.renderSlideJoint(e)),
        this.force > .001 && this.renderForce(e)
    }
    renderFixedJoint(e) {
        this.renderTriangle(e),
        e.beginPath();
        for (var t = -1; t <= 1; t++)
            e.moveTo(this.position[0] + 2.5 + 5 * t, this.position[1] + 15),
            e.lineTo(this.position[0] - 2.5 + 5 * t, this.position[1] + 20);
        e.stroke()
    }
    renderSlideJoint(e) {
        this.renderTriangle(e),
        e.beginPath(),
        e.moveTo(this.position[0] - 10, this.position[1] + 20),
        e.lineTo(this.position[0] + 10, this.position[1] + 20),
        e.stroke()
    }
    renderTriangle(e) {
        e.strokeStyle = this.selected ? this.selectedColor : this.color,
        e.lineWidth = 2,
        e.lineCap = "round",
        e.beginPath(),
        e.moveTo(this.position[0] - 10, this.position[1] + 15),
        e.lineTo(this.position[0] + 10, this.position[1] + 15),
        e.moveTo(this.position[0] + 5, this.position[1] + 15),
        e.lineTo(this.position[0], this.position[1]),
        e.lineTo(this.position[0] - 5, this.position[1] + 15),
        e.stroke()
    }
    renderForce(e) {
        e.strokeStyle = this.selected ? this.selectedColor : this.color,
        e.lineWidth = 2,
        e.lineCap = "round";
        var t = this.moving ? this.motionRadius : this.stillRadius
          , i = 10 * Math.log(Math.max(this.force, 10)) + t;
        e.beginPath(),
        e.moveTo(this.position[0], this.position[1] + i),
        e.lineTo(this.position[0], this.position[1]),
        e.moveTo(this.position[0], this.position[1] + i),
        e.lineTo(this.position[0] - 5, this.position[1] + i - 5),
        e.moveTo(this.position[0], this.position[1] + i),
        e.lineTo(this.position[0] + 5, this.position[1] + i - 5),
        e.stroke(),
        e.fillStyle = e.strokeStyle,
        e.textAlign = "center",
        e.fillText(`${+this.force.toFixed(2)}N`, this.position[0], this.position[1] + i + 10)
    }
    containPoint(e) {
        return Math.hypot(this.position[0] - e[0], this.position[1] - e[1]) < this.stillRadius + 2
    }
}

class Beam {
    constructor(e, t) {
        this.jointA = e,
        this.jointB = t,
        this.thickness = 3,
        this.color = "#95a5a6",
        this.tensionColor = "#2980b9",
        this.compressionColor = "#e67e22",
        this.quantity = 1,
        this.tensionForce = 0,
        this.distributedForce = 0,
        this.length = 0,
        this.tensionForceLabel = null,
        this.distributedForceLabel = null,
        this.physicalLengthLabel = null,
        this.draggable = !1
    }

    isConnectedToJoint(e) {
        return this.jointA == e || this.jointB == e
    }
    updateLength(e, t) {
        var i = this.jointA.position
          , o = this.jointB.position;
        this.length = (Math.hypot(i[1] - o[1], i[0] - o[0]))/10,
        this.physicalLength = this.length / e, 
        this.physicalLengthLabel = String(+this.physicalLength.toFixed(2)) + t
    }
    updateTensionForce(e, t) {
        var i, o = +Math.abs(e).toFixed(2);
        i = o < 1e-4 ? "" : e > 0 ? " (T)" : " (C)",
        this.tensionForce = e,
        this.tensionForceLabel = String(o) + t + i
    }
    updateDistributedForce(e, t) {
        if (this.distributedForce = e,
        e < 1e-4)
            this.distributedForceLabel = null;
        else {
            let i = +e.toFixed(2);
            this.distributedForceLabel = `⇃${i}${t}⇂`
        }
    }
    invalidateTensionForce() {
        this.tensionForce = 0,
        this.tensionForceLabel = null
    }
    directionVector(e) {
        if (!this.isConnectedToJoint(e))
            return [0, 0];
        var t = this.jointA.position
          , i = this.jointB.position
          , o = (i[0] - t[0]) / this.length
          , n = (i[1] - t[1]) / this.length;
        return this.jointA == e ? [o, n] : [-o, -n]
    }
    lineWidth() {
        return this.quantity > 1 ? this.thickness * Math.log2(this.quantity + 1) : this.thickness * this.quantity
    }
    center() {
        var e = this.jointA.position
          , t = this.jointB.position;
        return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2]
    }
    render(e) {
        var t = this.jointA.position
          , i = this.jointB.position;
        if (e.lineWidth = this.lineWidth(),
        this.selected ? e.strokeStyle = "red" : !this.tensionForceLabel || Math.abs(this.tensionForce) < .001 ? e.strokeStyle = this.color : this.tensionForce > 0 ? e.strokeStyle = this.tensionColor : e.strokeStyle = this.compressionColor,
        e.beginPath(),
        e.moveTo(t[0], t[1]),
        e.lineTo(i[0], i[1]),
        e.stroke(),
        this.quantity > 1) {
            var o = this.center();
            e.beginPath(),
            e.fillStyle = "white",
            e.arc(o[0], o[1], 6, 0, 2 * Math.PI),
            e.fill(),
            e.fillStyle = "black",
            e.textAlign = "center",
            e.textBaseline = "middle",
            e.fillText(this.quantity, o[0], o[1])
        }
        this.renderLabels(e)
    }
    renderLabels(e) {
        var t = this.jointA.position
          , i = this.jointB.position
          , o = [t[0] + i[0], t[1] + i[1]];
        o[0] /= 2,
        o[1] /= 2;
        var n = Math.atan2(t[1] - i[1], t[0] - i[0]);
        n > Math.PI / 2 ? n -= Math.PI : n < -Math.PI / 2 && (n -= Math.PI),
        e.save(),
        e.translate(o[0], o[1]),
        e.rotate(n),
        e.fillStyle = "black",
        e.textAlign = "center",
        e.textBaseline = "bottom";
        let s = [this.physicalLengthLabel, this.distributedForceLabel];
        s = s.filter(Boolean),
        e.fillText(s.join(" "), 0, -this.lineWidth()),
        this.tensionForceLabel && e.fillText(this.tensionForceLabel, 0, this.lineWidth() + 12),
        e.restore()
    }
    containPoint(e) {
        var t = this.lineWidth() / 2 + 3
          , i = this.jointA.position
          , o = this.jointB.position
          , n = o[0] - i[0]
          , s = o[1] - i[1]
          , r = o[0] * i[1] - o[1] * i[0]
          , l = Math.abs(s * e[0] - n * e[1] + r);
        l /= Math.hypot(n, s);
        var a = [Math.min(i[0], o[0]), Math.max(i[0], o[0])]
          , d = [Math.min(i[1], o[1]), Math.max(i[1], o[1])]
          , c = l < t;
        return c = (c = (c = (c = c && e[0] > a[0] - t) && e[0] < a[1] + t) && e[1] > d[0] - t) && e[1] < d[1] + t
    }
}
let bridgeModel = function() {
    let e = {
        beams: [],
        joints: [],
        temporaryJoint: null,
        temporaryBeam: null,
        lengthUnit: "m",
        pixelToLengthRatio: 2.4,
        forceUnit: "N",
        distributedForceUnit: "N/m",
        totalCost: 0,
        evaluatedCost: 0,
        invalidCostError: !1,
        addJoint: t=>{
            e.joints.push(t);




        }
        ,
        // remove
        removeJoint: t=>{
            t.mirrorJoint && (t.mirrorJoint.mirrorJoint = null),
            e.beams = e.beams.filter(e=>!e.isConnectedToJoint(t));
            let i = e.joints.indexOf(t);
            e.joints.splice(i, 1)
            render();
        }
        ,
        removeBeam: t=>{
            e.beams.splice(e.beams.indexOf(t), 1)

            addActionToHistory({ type: ActionType.DELETE_BEAM, data: {Beam} });
            render();
        }
        ,
        mergeRedundantBeams: (t,i)=>{
            let o;
            for (let l = e.beams.length - 1; l >= 0; l--) {
                var n = e.beams[l]
                  , s = n.isConnectedToJoint(t)
                  , r = n.isConnectedToJoint(i);
                s && r && (o ? (o.quantity += n.quantity,
                e.beams.splice(l, 1)) : o = n)
            }
        }
        ,
        mergeJoint: (t,i)=>{
            if (t != i) {
                for (var o = [], n = e.beams.length - 1; n >= 0; n--) {
                    var s = e.beams[n]
                      , r = s.isConnectedToJoint(t)
                      , l = s.isConnectedToJoint(i);
                    r && l ? e.beams.splice(n, 1) : l && (s.jointA == i ? (s.jointA = t,
                    o.push(s.jointB)) : (s.jointB = t,
                    o.push(s.jointA)))
                }
                e.joints.splice(e.joints.indexOf(i), 1);
                for (let i of o)
                    e.mergeRedundantBeams(t, i)
            }
        }
    };
    e.update = (()=>{
        e.invalidCostError = !1,
        (t=>{
            const i = null == t;
            for (let o of e.beams)
                (i || o.isConnectedToJoint(t)) && o.updateLength(e.pixelToLengthRatio, e.lengthUnit)
        }
        )(),
        (()=>{
            for (let t of e.joints)
                t.force = t.applyForce;
            for (let t of e.beams) {
                let e = t.distributedForce * t.physicalLength / 2;
                t.jointA.force += e,
                t.jointB.force += e
            }
        }
        )(),
        (()=>{
            var t = e.beams.length
              , i = 0
              , o = [];
            for (let t of e.joints)
                "f" == t.jointType ? i += 2 : "s" == t.jointType && (i += 1),
                o.push(t);
            if ((t += i) == 2 * e.joints.length) {
                var n, s = 0, r = new Array(i).fill(0), l = [], a = [];
                for (let t of e.joints) {
                    var d = []
                      , c = [];
                    for (let i of e.beams) {
                        var h = i.directionVector(t);
                        d.push(h[0]),
                        c.push(h[1])
                    }
                    if ("f" == t.jointType) {
                        var p = r.slice()
                          , m = r.slice();
                        p[s] = 1,
                        m[s + 1] = 1,
                        s += 2,
                        d = d.concat(p),
                        c = c.concat(m)
                    } else
                        "s" == t.jointType ? ((m = r.slice())[s] = 1,
                        s += 1,
                        d = d.concat(r),
                        c = c.concat(m)) : (d = d.concat(r),
                        c = c.concat(r));
                    l.push(d),
                    l.push(c),
                    a.push(0),
                    a.push(-t.force)
                }
                try {
                    n = numeric.dotMV(numeric.inv(l), a)
                } catch (e) {
                    n = null
                }
                n ? (e.beams.forEach((t,i)=>{
                    t.updateTensionForce(n[i], e.forceUnit)
                }
                ),
                s = e.beams.length,
                o.forEach(e=>{
                    "f" == e.jointType ? (e.supportForce = [-n[s], -n[s + 1]],
                    i += 2) : "s" == e.jointType && (e.supportForce = [0, -n[s]],
                    i += 1)
                }
                )) : e.invalidCostError = !0
            } else
                e.beams.forEach(e=>{
                    e.invalidateTensionForce()
                }
                )
        }
        )(),
        (()=>{
            e.totalCost = 0,
            e.evaluatedCost = 0;
            for (let t of e.beams) {
                e.totalCost += t.quantity * t.physicalLength * 31222, // multiplicar coste por 100
                t.physicalLength < 1 && (e.invalidCostError = !0);
                let i = 0;
                Math.abs(t.tensionForce) < 1e-4 ? i = 312.22 * t.physicalLength : t.tensionForce > 0 ? (i = Math.ceil(t.tensionForce / 13) * t.physicalLength * 31222,// coste
                Math.ceil(t.tensionForce / 13) > 2.1 && (e.invalidCostError = !0)) : (i = Math.ceil(-t.tensionForce / 8) * t.physicalLength * 31222,//coste
                Math.ceil(-t.tensionForce / 8) > 2.1 && (e.invalidCostError = !0)),
                e.evaluatedCost += i
            }
            e.totalCost += 6 * e.joints.length, // precio artuciculaciones
            e.evaluatedCost += 6 * e.joints.length// precio artuciculaciones
        }
        )()
    }
    );
    let t = (e,t)=>(t = Math.abs(t),
    e = Math.abs(e),
    Math.floor(e / t) * t);
    return e.optimizeJoint = ((i,o,n,s)=>{
        i.engine.ignoreUpdateRequest = !0,
        e.update(),
        e.invalidCostError && (e.evaluatedCost *= 1e4);
        let r = [[e.evaluatedCost, i.position.slice()]];
        o *= e.pixelToLengthRatio,
        n *= e.pixelToLengthRatio,
        s *= e.pixelToLengthRatio;
        let l = [i.position[0] - t(o, s), i.position[0] + t(o, s)]
          , a = [i.position[1] - t(n, s), i.position[1] + t(n, s)]
          , d = t(o, s) / s * 2;
        d *= t(n, s) / s * 2;
        let c = 0
          , h = 0;
        for (let t = l[0]; t <= l[1]; t += s)
            for (let o = a[0]; o <= a[1]; o += s) {
                let n = [t, o];
                i.updatePosition(n, {
                    ignoreLock: !0
                }),
                e.update(),
                e.invalidCostError || r.push([e.evaluatedCost, n]),
                r.length > 5 && (r.sort((e,t)=>e[0] == t[0] ? e[1] < t[1] ? -1 : e[1] > t[1] ? 1 : 0 : e[0] < t[0] ? -1 : e[0] > t[0] ? 1 : 0),
                r.pop()),
                Math.floor(c / d * 10) >= h && (console.log(`Progress: ${10 * h}%`),
                h += 1),
                c++
            }
        r.sort(),
        i.updatePosition(r[0][1]),
        i.engine.ignoreUpdateRequest = !1,
        i.engine.requestUpdate();
        let p = "---optimizeJoint---\n";
        for (let e of r) {
            let t = i.engine.translateToCartesianPosition(e[1]);
            p += `(${+t[0].toFixed(4)}, ${+t[1].toFixed(4)}) cost: ${e[0].toFixed(4)}\n` //texto cosste
        }
        console.log(p)
    }
    ),
    e
}()
  , renderEngine = function() {
    let e = {
        padding: 10,
        requireLogicUpdate: !1,
        requireGraphicsUpdate: !1,
        fpsMeasurements: 0,
        fpsAverage: 0,
        fpsDisplay: 0,
        ignoreUpdateRequest: !1,
        setup: (t,i)=>{
            e.canvas = t,
            e.context = t.getContext("2d"),
            e.model = i,
            e.resize(),
            e.lastTimestamp = performance.now() - 1,
            e.requestUpdate(),
            e.loop()
        }
    };
    return e.resize = (()=>{
        e.width = e.canvas.width,
        e.height = e.canvas.height;
        ((e,t)=>{
            var i = 1;
            "devicePixelRatio"in window && window.devicePixelRatio > 1 && (i = window.devicePixelRatio);
            var o = e.width
              , n = e.height;
            e.width = o * i,
            e.height = n * i,
            e.style.width = o + "px",
            e.style.height = n + "px",
            t.scale(i, i)
        }
        )(e.canvas, e.context);
        e.positionRanges = {
            x: [e.padding, e.canvas.width - e.padding],
            y: [e.padding, e.canvas.height - e.padding]
        };
        let t = [e.width / 2, 0];
        (t = e.translateToCartesianPosition(t))[0] = 10 * Math.round(t[0] / 10),
        e.mirrorCartesianX = t[0],
        t = e.translateFromCartesianPosition(t),
        e.mirrorX = t[0],
        e.requestUpdate()
    }
    ),
    e.requestUpdate = (()=>{
        e.ignoreUpdateRequest || (e.requireLogicUpdate = !0,
        e.requireGraphicsUpdate = !0)
    }
    ),
    e.loop = (t=>{
        e.requireLogicUpdate && (e.model.update(),
        e.requireLogicUpdate = !1,
        e.requireGraphicsUpdate = !0),
        e.requireGraphicsUpdate && (e.render(t),
        e.requireGraphicsUpdate = !1),
        window.requestAnimationFrame(e.loop)
    }
    ),
    e.render = (t=>{
        e.lastTimestamp;
        e.context.clearRect(0, 0, e.canvas.width, e.canvas.height),
        e.renderMirrorLine();
        for (let t of e.model.beams)
            t.render(e.context);
        e.model.temporaryBeam && e.model.temporaryBeam.render(e.context);
        for (let t of e.model.joints)
            t.render(e.context);
        e.model.temporaryJoint && e.model.temporaryJoint.render(e.context),
        e.renderCost(),
        e.lastTimestamp = t

        
    }
    ),
    e.renderFPS = (t=>{
        var i = 1e3 / t;
        e.context.fillStyle = "black",
        e.context.textAlign = "start",
        e.context.textBaseline = "alphabetic",
        e.context.fillText(`FPS: ${i}`, 10, 18)
    }
    ),
    e.renderCost = (()=>{
        e.context.save(),
        e.context.font = "20px sans-serif",
        e.context.fillStyle = "black",
        e.context.textAlign = "start";
        let t = ` Cost:  ${e.model.evaluatedCost.toFixed(4)} €`   ;
        e.context.fillText(t, 10, 30),
        e.model.invalidCostError && (e.context.fillStyle = "red"),
        e.context.restore()
    }
    ),
    e.renderMirrorLine = (()=>{
        e.context.save(),
        e.context.font = "10px sans-serif",
        e.context.fillStyle = "#000",
        e.context.textAlign = "center",
        e.context.fillText(e.mirrorCartesianX, e.mirrorX, 15),
        e.context.setLineDash([5, 50]),
        e.context.strokeStyle = "#0000",
        e.context.lineWidth = 1,
        e.context.beginPath(),
        e.context.moveTo(e.mirrorX, 30),
        e.context.lineTo(e.mirrorX, e.height),
        e.context.stroke(),
        e.context.restore()
    }
    ),
    e.print = (()=>{
        var t = "";
        for (let i of e.model.joints) {
            let o = e.translateToCartesianPosition(i.position);
            o[0] = +o[0].toFixed(4),
            o[1] = +o[1].toFixed(4),
            t += "(" + o.join(", ") + ")\r\n"
        }
        console.log(t),
        window.prompt("Copy to clipboard: Ctrl+C, Enter", t)
    }
    ),
    e.objectAtPosition = ((t,i)=>{
        let o = e.jointAtPosition(t, i);
        return o || (o = e.beamAtPosition(t, i)),
        o
    }
    ),



    e.jointAtPosition = ((t,i)=>{
        for (let o of e.model.joints)
            if (o != i && o.containPoint(t))
                return o;
        return null
    }
    ),
    e.beamAtPosition = ((t,i)=>{
        for (let o of e.model.beams)
            if (o != i && o.containPoint(t))
                return o;
        return null
    }
    ),




    e.translateToAbsolutePosition = (t=>{
        var i = e.canvas.getBoundingClientRect();
        return [i.left + t[0], i.top + t[1]]
    }
    ),
    e.translateToCartesianPosition = (t=>[t[0] / e.model.pixelToLengthRatio, (e.height - t[1]) / e.model.pixelToLengthRatio]),
    e.translateFromCartesianPosition = (t=>[t[0] * e.model.pixelToLengthRatio, e.height - t[1] * e.model.pixelToLengthRatio]),
    e.clipPosition = (t=>{
        return [Math.min(Math.max(t[0], e.positionRanges.x[0]), e.positionRanges.x[1]), Math.min(Math.max(t[1], e.positionRanges.y[0]), e.positionRanges.y[1])]
    }
    ),
    e
}()
  , touchController = function() {
    let e = {
        setup: t=>{
            t.addEventListener("mousedown", i),
            t.addEventListener("mousemove", o),
            t.addEventListener("mouseup", n),
            t.addEventListener("mouseleave", n),
            t.addEventListener("touchstart", i),
            t.addEventListener("touchmove", o),
            t.addEventListener("touchend", n),
            t.addEventListener("touchcancel", n),
            e.canvas = t
        }
        ,
        objectAtPosition: e=>null,
        updateLocation: (e,t)=>{}
        ,
        clicked: (e,t)=>{}
        ,
        dragEnded: (e,t)=>{}
        ,
        mouseDownInside: !1,
        previousPosition: [NaN, NaN]
    };
    var t = t=>{
        var i, o = e.canvas.getBoundingClientRect();
        return i = void 0 !== t.touches && 0 !== t.touches.length ? [t.touches[0].clientX - o.left - 3, t.touches[0].clientY - o.top - 3] : [t.clientX - o.left - 3, t.clientY - o.top - 3],
        isNaN(i[0]) || isNaN(i[1]) ? e.previousPosition : (e.previousPosition = i,
        i)
    }
      , i = i=>{
        console.log("mouseDown"),
        e.shiftKey = i.shiftKey;
        let o = t(i);
        e.trackingObject = e.objectAtPosition(o),
        e.trackingObject && (e.lastClicked = e.trackingObject),
        e.mouseDownTimestamp = performance.now(),
        e.mouseDownPosition = o,
        e.dragging = !1,
        e.mouseDownInside = !0,
        i.preventDefault()
    }
      , o = i=>{
        if (console.log("mouseMove"),
        !e.mouseDownInside)
            return;
        let o = t(i);
        if (e.dragging)
            e.updateLocation(e.trackingObject, o);
        else {
            let t = performance.now() - e.mouseDownTimestamp;
            (Math.hypot(e.mouseDownPosition[0] - o[0], e.mouseDownPosition[1] - o[1]) > 5 || t > 300) && (e.dragging = e.updateLocation(e.trackingObject, o))
        }
        i.preventDefault()
    }
      , n = i=>{
        if (!e.mouseDownInside)
            return;
        let o = t(i);
        e.dragging ? (console.log("dragEnded"),
        e.dragEnded(e.trackingObject, o)) : (console.log("clicked", o),
        e.clicked(e.trackingObject, o)),
        e.trackingObject = null,
        e.mouseDownInside = !1,
        i.preventDefault()
    }
    ;
    return e
}()
  , jointEditor = function() {
    let editor = {}
      , _enabled = !1
      , _domElements = {}
      , _selectedJoint = null
      , _engine = null
      , _model = null
      , _lastParameters = "";
    editor.setup = ((e,t)=>{
        _domElements.editor = document.getElementById("position-editor"),
        _domElements.xField = document.getElementById("position-editor-x"),
        _domElements.yField = document.getElementById("position-editor-y"),
        _domElements.forceField = document.getElementById("position-editor-f"),
        _domElements.mirrorButton = document.getElementById("position-editor-mir"),
        _domElements.lockXButton = document.getElementById("position-editor-lock-x"),
        _domElements.lockYButton = document.getElementById("position-editor-lock-y"),
        _domElements.showPosButton = document.getElementById("position-editor-show-pos"),
        _engine = e,
        _model = t
    }
    ),
    editor.enableForJoint = (e=>{
        if (e == _selectedJoint)
            return;
        _enabled && (_selectedJoint.selected = !1),
        (_selectedJoint = e).selected = !0,
        _engine.requestUpdate();
        let t = _selectedJoint.position
          , i = _engine.translateToCartesianPosition(t);
        setPositionFields(i),
        setForceField(_selectedJoint.applyForce),
        _enabled = !0,
        _domElements.editor.style.display = "block",
        updateEditorPosition(),
        updateEditorButtonText()
    }
    ),
    editor.disable = (()=>{
        _enabled && (_selectedJoint && (_selectedJoint.selected = !1,
        _selectedJoint = null,
        _engine.requestUpdate()),
        _enabled = !1,
        _domElements.editor.style.display = "none")
    }
    );
    var setPositionFields = e=>{
        _domElements.xField.value = +e[0].toFixed(2),
        _domElements.yField.value = +e[1].toFixed(2)
    }
      , setForceField = e=>{
        _domElements.forceField.value = +e.toFixed(3)
    }
      , readForceField = ()=>parseFloat(_domElements.forceField.value)
      , readPositionFields = ()=>{
        var x, y;
        let position = _selectedJoint.position
          , cartesianPosition = _engine.translateToCartesianPosition(position)
          , center = _engine.mirrorCartesianX;
        try {
            let readValue = eval(_domElements.xField.value);
            x = parseFloat(readValue)
        } catch (e) {
            x = cartesianPosition[0]
        }
        try {
            let readValue = eval(_domElements.yField.value);
            y = parseFloat(readValue)
        } catch (e) {
            y = cartesianPosition[1]
        }
        return [x, y]
    }
      , updateEditorPosition = ()=>{
        let e = _selectedJoint.position
          , t = _engine.translateToAbsolutePosition(e)
          , i = _domElements.editor.clientWidth
          , o = _domElements.editor.clientHeight;
        t[0] < _engine.width / 2 ? _domElements.editor.style.left = t[0] + 50 + "px" : _domElements.editor.style.left = t[0] - i - 50 + "px",
        t[1] < _engine.height / 4 ? _domElements.editor.style.top = t[1] + "px" : t[1] > 3 * _engine.height / 4 ? _domElements.editor.style.top = t[1] - o + "px" : _domElements.editor.style.top = t[1] - o / 2 + "px"
    }
      , updateEditorButtonText = ()=>{
        _selectedJoint.positionLock.x ? _domElements.lockXButton.innerHTML = "Unlock X" : _domElements.lockXButton.innerHTML = "Lock X",
        _selectedJoint.positionLock.y ? _domElements.lockYButton.innerHTML = "Unlock Y" : _domElements.lockYButton.innerHTML = "Lock Y"

    }
    ;
    return editor.updateButton = (()=>{
        var e = readPositionFields()
          , t = _engine.translateFromCartesianPosition(e);
        _selectedJoint.updatePosition(_engine.clipPosition(t), {
            ignoreLock: !0
        }),
        _selectedJoint.applyForce = readForceField(),
        updateEditorPosition(),
        _engine.requestUpdate()
    }
    ),
   
    
    
    editor.lockButton = (e=>{
        _selectedJoint.positionLock[e] = !_selectedJoint.positionLock[e],
        updateEditorButtonText()
    }
    ),
    editor.closeButton = (()=>{
        editor.disable()
    }
    ),
    editor.jointTypeButton = (e=>{
        _selectedJoint.jointType = e,
        _engine.requestUpdate()
    }
    ),
    editor.removeButton = (()=>{
        _model.removeJoint(_selectedJoint),
        _selectedJoint = null,
        editor.disable(),
        _engine.requestUpdate()
        
        const index = bridgeModel.joints.indexOf(_selectedJoint); //historiakl
        if (index > -1) {
            bridgeModel.joints.splice(index, 1);
            history.addActionToHistory(new RemoveJointAction(_selectedJoint));
    }
    

    }
    ),
    editor.showPositionButton = (()=>{
        _selectedJoint.showPosition = !_selectedJoint.showPosition,
        updateEditorButtonText(),
        _engine.requestUpdate()
    }
    ),
    editor.optimizeButton = (()=>{
        let e = window.prompt("X Range, Y Range, Step", _lastParameters);
        if (3 == (e = e.split(",").map(parseFloat)).length) {
            _lastParameters = e;
            let t = _selectedJoint;
            editor.disable(),
            _model.optimizeJoint(t, e[0], e[1], e[2]),
            window.alert("Optimized")
        } else
            window.alert("Invalid parameters")
    }
    ),
    editor
}()
  , beamEditor = function() {
    let e = {}
      , t = !1
      , i = {}
      , o = null
      , n = null
      , s = null;
    e.setup = ((e,t)=>{
        i.editor = document.getElementById("beam-editor"),
        i.forceField = document.getElementById("beam-editor-f"),
        n = e,
        s = t
    }
    ),
    e.enableForBeam = (e=>{
        if (e == o)
            return;
        t && (o.selected = !1),
        (o = e).selected = !0,
        n.requestUpdate();
        o.center;
        r(o.distributedForce),
        t = !0,
        i.editor.style.display = "block",
        l()
    }
    ),
    e.disable = (()=>{
        t && (o && (o.selected = !1,
        o = null,
        n.requestUpdate()),
        t = !1,
        i.editor.style.display = "none")
    }
    );
    var r = e=>{
        i.forceField.value = +e.toFixed(3)
    }
      , l = ()=>{
        let e = o.center()
          , t = n.translateToAbsolutePosition(e)
          , s = i.editor.clientWidth
          , r = i.editor.clientHeight;
        t[0] < n.width / 2 ? i.editor.style.left = t[0] + 50 + "px" : i.editor.style.left = t[0] - s - 50 + "px",
        t[1] < n.height / 4 ? i.editor.style.top = t[1] + "px" : t[1] > 3 * n.height / 4 ? i.editor.style.top = t[1] - r + "px" : i.editor.style.top = t[1] - r / 2 + "px"
    }
    ;
    return e.updateButton = (()=>{
        o.updateDistributedForce((()=>parseFloat(i.forceField.value))(), s.distributedForceUnit),
        n.requestUpdate()
    }
    ),
    e.closeButton = (()=>{
        e.disable()
    }
    ),
    e.removeButton = (()=>{
        s.removeBeam(o),
        o = null,
        e.disable(),
        n.requestUpdate()
    }
    ),
    e
}();
var creationMode = !1;
function resizeCanvas() {
    var e = document.getElementById("main-canvas")
      , t = document.querySelector(".container");
    e.width = t.clientWidth - 20,
    e.height = t.clientHeight - 20
}
touchController.objectAtPosition = (e=>renderEngine.objectAtPosition(e)),
touchController.updateLocation = ((e,t)=>{
    if (!e || !e.draggable) return !1;
    let i = renderEngine.clipPosition(t);
    let snappedPosition = snapToGrid(i[0], i[1], gridSize); // Ajuste a la cuadrícula
    return creationMode ? (bridgeModel.temporaryJoint || (bridgeModel.temporaryJoint = new Joint(renderEngine),
    bridgeModel.temporaryJoint.position = snappedPosition, // Usar posición ajustada
    bridgeModel.temporaryJoint.moving = !0,
    bridgeModel.temporaryBeam = new Beam(e,bridgeModel.temporaryJoint)),
    bridgeModel.temporaryJoint.updatePosition(snappedPosition)) : (e.updatePosition(snappedPosition), // Usar posición ajustada
    e.moving = !0),
    renderEngine.requestUpdate(),
    !0
}
);

touchController.clicked = (e, t) => {
    if (e) {
      if (e instanceof Joint) {
        beamEditor.disable();
        jointEditor.enableForJoint(e);
      } else if (e instanceof Beam) {
        jointEditor.disable();
        beamEditor.enableForBeam(e);
      }
    } else if (creationMode) {
      let snappedPosition = isGridActive ? snapToGrid(t[0], t[1], gridSize) : t; // Ajuste a la cuadrícula si está activa
      let newJoint = new Joint(renderEngine);
      bridgeModel.joints.push(newJoint);
      newJoint.updatePosition(snappedPosition, { ignoreLock: !0 }); // Usar posición ajustada
      renderEngine.requestUpdate();
      history.addActionToHistory(new AddJointAction(newJoint)); // Historial
    }
  };

touchController.dragEnded = (e, t) => {
    // Clip the position and optionally snap to grid
    let clippedPosition = renderEngine.clipPosition(t);
    let snappedPosition = isGridActive ? snapToGrid(clippedPosition[0], clippedPosition[1], gridSize) : clippedPosition;

    // Determine if there is a joint at the snapped position
    let jointAtPos = renderEngine.jointAtPosition(snappedPosition, e);

    if (creationMode) {
        if (!bridgeModel.temporaryJoint) return;

        // Update temporary joint with snapped position
        bridgeModel.temporaryJoint.updatePosition(snappedPosition);
        bridgeModel.temporaryJoint.moving = !1;

        if (jointAtPos) {
            // Update beam if joint exists
            if (bridgeModel.temporaryBeam.jointA != jointAtPos) {
                bridgeModel.temporaryBeam.jointB = jointAtPos;
                bridgeModel.beams.push(bridgeModel.temporaryBeam);
                bridgeModel.mergeRedundantBeams(bridgeModel.temporaryBeam.jointA, jointAtPos);
                renderEngine.requestUpdate();
            }
        } else {
            // Add new joint and beam
            bridgeModel.addJoint(bridgeModel.temporaryJoint);
            bridgeModel.beams.push(bridgeModel.temporaryBeam);
            renderEngine.requestUpdate();
        }

        // Update history
        history.addActionToHistory(new AddJointAction(bridgeModel.temporaryJoint));
        history.addActionToHistory(new AddBeamAction(bridgeModel.temporaryBeam));

        // Clear temporary objects
        bridgeModel.temporaryBeam = null;
        bridgeModel.temporaryJoint = null;
    } else if (e) {
        // Update existing joint with snapped position
        e.updatePosition(snappedPosition);
        e.moving = !1;

        if (jointAtPos) {
            bridgeModel.mergeJoint(jointAtPos, e);
        }

        renderEngine.requestUpdate();
    }
};


window.onload = function() {
    var e = document.getElementById("main-canvas");
    resizeCanvas(),
    renderEngine.setup(e, bridgeModel),
    touchController.setup(renderEngine.canvas),
    jointEditor.setup(renderEngine, bridgeModel),
    beamEditor.setup(renderEngine, bridgeModel),
    window.addEventListener("resize", e=>{
        resizeCanvas(),
        renderEngine.resize()
    }
    )
}












function createStableBridge(length) {
    // Limpiar juntas y vigas existentes
    bridgeModel.joints = [];
    bridgeModel.beams = [];

    // Altura del puente en unidades (ajustada)
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const centerX = windowWidth / 2;
    const centerY = windowHeight * 0.55;
    const startX = centerX - length / 2; // Calcular el inicio del puente

    // Función para verificar si una junta ya existe
    function jointExists(position) {
        return bridgeModel.joints.some(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
    }

    // Función para verificar si una viga ya existe
    function beamExists(jointA, jointB) {
        return bridgeModel.beams.some(beam =>
            (beam.jointA === jointA && beam.jointB === jointB) ||
            (beam.jointA === jointB && beam.jointB === jointA)
        );
    }

    // Función para agregar una nueva junta si no existe
    function addJoint(position, type = 'null') {
        let existingJoint = bridgeModel.joints.find(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
        if (!existingJoint) {
            const newJoint = new Joint(renderEngine);
            newJoint.position = position;
            newJoint.jointType = type;
            bridgeModel.joints.push(newJoint);
            return newJoint;
        } else if (type === 'f') {
            existingJoint.jointType = type; // Actualizar la junta existente a fija si se necesita
        }
        return existingJoint;
    }

    // Función para agregar una nueva viga si no existe
    function addBeam(jointA, jointB) {
        if (!beamExists(jointA, jointB)) {
            const newBeam = new Beam(jointA, jointB);
            bridgeModel.beams.push(newBeam);
        }
    }

    if (length <= 240) {
        // Crear juntas
        const height = length * 0.75;
        const jointA = addJoint([startX, centerY], 'f');
        const middlePosition = startX + (length / 2);
        const middleJoint = addJoint([middlePosition, centerY]);
        const jointB = addJoint([startX + length, centerY], 'f');
        const jointTop = addJoint([centerX, centerY - height]);

        // Crear vigas
        addBeam(jointA, jointTop);
        addBeam(middleJoint, jointTop);
        addBeam(jointB, jointTop);
        addBeam(jointA, middleJoint);
        addBeam(middleJoint, jointB);
    } else {
        const height = 180;
        // Calcular el número de segmentos de 120 unidades
        const segments = Math.floor(length / 120);

        // Crear el primer jointA
        const jointA = addJoint([startX  - (length % 120) / 2, centerY], 'f');
        let previousJoint = jointA;
        let previousTopJoint = null;

        for (let i = 0; i <= segments; i++) {
            const joint = addJoint([startX + i * 120, centerY]);

            // Crear la junta superior (triángulo) solo si no es el último segmento
            const jointTop = addJoint([startX + i * 120, centerY - height]);

            // Crear vigas para formar el triángulo
            addBeam(previousJoint, jointTop);
            addBeam(joint, jointTop);
            addBeam(previousJoint, joint);

            // Crear viga entre los triángulos
            if (previousTopJoint) {
                addBeam(previousTopJoint, jointTop);
            }

            previousTopJoint = jointTop;
            previousJoint = joint;
        }

        // Crear el último jointB como fijo ('f')
        const jointBPosition = [startX + 120 * segments + (length % 120) / 2, centerY];
        const jointB = addJoint(jointBPosition, 'f');

        // Crear vigas para el último segmento si la longitud no es múltiplo exacto de 120
        addBeam(previousJoint, jointB);

        // Crear vigas entre juntas principales
        for (let i = 0; i < bridgeModel.joints.length - 1; i++) {
            addBeam(bridgeModel.joints[i], bridgeModel.joints[i + 1]);
        }
    }
}



function createStableBridge2(length) {
    // Limpiar juntas y vigas existentes
    bridgeModel.joints = [];
    bridgeModel.beams = [];

    const maxSegmentLength = 5 * 24; // 5 metros en unidades
    const segments = Math.ceil(length / maxSegmentLength);
    const segmentLength = length / segments;
    const height = segmentLength * 0.75;

    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const centerX = windowWidth / 2;
    const centerY = windowHeight * 0.55;
    const startX = centerX - length / 2;

    // Función para agregar una nueva junta si no existe
    function addJoint(position, type = 'null') {
        let existingJoint = bridgeModel.joints.find(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
        if (!existingJoint) {
            const newJoint = new Joint(renderEngine);
            newJoint.position = position;
            newJoint.jointType = type;
            bridgeModel.joints.push(newJoint);
            return newJoint;
        } else if (type === 'f') {
            existingJoint.jointType = type; // Actualizar la junta existente a fija si se necesita
        }
        return existingJoint;
    }

    // Función para agregar una nueva viga si no existe
    function addBeam(jointA, jointB) {
        if (!bridgeModel.beams.some(beam =>
            (beam.jointA === jointA && beam.jointB === jointB) ||
            (beam.jointA === jointB && beam.jointB === jointA)
        )) {
            const newBeam = new Beam(jointA, jointB);
            bridgeModel.beams.push(newBeam);
        }
    }

    const jointA = addJoint([startX, centerY], 'f');
    let previousJoint = jointA;
    let previousTopJoint = null;

    for (let i = 0; i < segments; i++) {
        const joint = addJoint([startX + (i + 1) * segmentLength, centerY]);
        const jointTop = addJoint([startX + i * segmentLength + segmentLength / 2, centerY - height]);

        addBeam(previousJoint, jointTop);
        addBeam(joint, jointTop);
        addBeam(previousJoint, joint);

        if (previousTopJoint) {
            addBeam(previousTopJoint, jointTop);
        }

        previousTopJoint = jointTop;
        previousJoint = joint;
    }

    const jointB = addJoint([startX + length, centerY], 'f');
    addBeam(previousJoint, jointB);
    addBeam(previousTopJoint, jointB);


}

function createArchBridge(length) {
    // Limpiar juntas y vigas existentes
    bridgeModel.joints = [];
    bridgeModel.beams = [];

    const numSegments = 20; // Ajusta esto según el nivel de detalle del arco
    const segmentLength = length / numSegments;

    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const centerX = windowWidth / 2;
    const centerY = windowHeight * 0.55;
    const startX = centerX - length / 2;

    const radius = length / 2;
    const arcHeight = radius; // Altura del arco en el punto medio

    // Función para agregar una nueva junta si no existe
    function addJoint(position, type = 'null') {
        let existingJoint = bridgeModel.joints.find(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
        if (!existingJoint) {
            const newJoint = new Joint(renderEngine);
            newJoint.position = position;
            newJoint.jointType = type;
            bridgeModel.joints.push(newJoint);
            return newJoint;
        } else if (type === 'f') {
            existingJoint.jointType = type; // Actualizar la junta existente a fija si se necesita
        }
        return existingJoint;
    }

    // Función para agregar una nueva viga si no existe
    function addBeam(jointA, jointB) {
        if (!bridgeModel.beams.some(beam =>
            (beam.jointA === jointA && beam.jointB === jointB) ||
            (beam.jointA === jointB && beam.jointB === jointA)
        )) {
            const newBeam = new Beam(jointA, jointB);
            bridgeModel.beams.push(newBeam);
        }
    }

    // Crear juntas fijas en los extremos
    const jointA = addJoint([startX, centerY], 'f');
    const jointB = addJoint([startX + length, centerY], 'f');

    let previousJoint = jointA;

    // Crear juntas y vigas para el arco
    for (let i = 1; i < numSegments; i++) {
        const x = startX + i * segmentLength;
        const y = centerY - Math.sqrt(Math.pow(radius, 2) - Math.pow((x - centerX), 2));

        const joint = addJoint([x, y]);

        addBeam(previousJoint, joint);
        previousJoint = joint;
    }

    // Conectar el último segmento del arco al jointB
    addBeam(previousJoint, jointB);

    // Crear carreteras
    const roadJoints = [];
    for (let i = 0; i <= numSegments; i++) {
        const x = startX + i * segmentLength;
        const roadJoint = addJoint([x, centerY]);
        roadJoints.push(roadJoint);

        // Conectar el arco a la carretera con vigas verticales y diagonales
        if (i > 0 && i < numSegments) {
            addBeam(bridgeModel.joints[i+1], roadJoint);
 
            // addBeam(bridgeModel.joints[i + 2], roadJoint); // Comentado para evitar las vigas innecesarias
        }
    }

    // Conectar las carreteras entre sí con vigas horizontales
    for (let i = 0; i < roadJoints.length - 1; i++) {
        addBeam(roadJoints[i], roadJoints[i + 1]);
    }
}




function createDoublePillarBridge(length) {
    // Limpiar juntas y vigas existentes
    bridgeModel.joints = [];
    bridgeModel.beams = [];

    const numSegments = 0; // Número de segmentos de la carretera (ahora 0)
    const segmentLength = length / (numSegments + 1); // Longitud del segmento (no usado en este caso)

    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const centerX = windowWidth / 2;
    const centerY = windowHeight * 0.55;
    const startX = centerX - length / 2;

    const pillarHeight = windowHeight * 0.2; // Altura de los pilares centrales

    // Función para agregar una nueva junta si no existe
    function addJoint(position, type = 'null') {
        let existingJoint = bridgeModel.joints.find(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
        if (!existingJoint) {
            const newJoint = new Joint(renderEngine);
            newJoint.position = position;
            newJoint.jointType = type;
            bridgeModel.joints.push(newJoint);
            return newJoint;
        } else if (type === 'f') {
            existingJoint.jointType = type; // Actualizar la junta existente a fija si se necesita
        }
        return existingJoint;
    }

    // Función para agregar una nueva viga si no existe
    function addBeam(jointA, jointB) {
        if (!bridgeModel.beams.some(beam =>
            (beam.jointA === jointA && beam.jointB === jointB) ||
            (beam.jointA === jointB && beam.jointB === jointA)
        )) {
            const newBeam = new Beam(jointA, jointB);
            bridgeModel.beams.push(newBeam);
        }
    }

    // Ajustar la separación de los pilares
    const pillarSeparation = length * 0.2; // Separación entre los pilares
    const maxPillarWidth = pillarSeparation * 0.8; // Ancho máximo de los pilares cerca de la carretera

    // Crear pilares centrales con forma creciente hacia los extremos (primeros 3 pilares) y verticales (últimos 3 pilares)
    const leftPillarJoints = [];
    const rightPillarJoints = [];

    for (let i = 0; i <= 5; i++) {
        let pillarWidth;
        if (i < 3) {
            // Pilares crecientes hacia los extremos
            pillarWidth = maxPillarWidth * (i / 3);
        } else {
            // Pilares verticales en los últimos 3
            pillarWidth = maxPillarWidth;
        }

        // Calcular la posición del joint del pilar
        const offsetX = (maxPillarWidth - pillarWidth) / 2;
        const offsetY = i * pillarHeight / 5;

        // Determinar el tipo de joint (fijo o nulo)
        let jointType = 'null';
        if (i === 5) {
            jointType = 'f'; // Último joint es fijo
        }

        // Crear los joints de los pilares
        const leftPillarJoint = addJoint([centerX - pillarSeparation / 2 - offsetX, centerY + offsetY], jointType);
        const rightPillarJoint = addJoint([centerX + pillarSeparation / 2 + offsetX, centerY + offsetY], jointType);

        leftPillarJoints.push(leftPillarJoint);
        rightPillarJoints.push(rightPillarJoint);

        // Conectar los pilares con vigas si no es el primer pilar
        if (i > 0) {
            addBeam(leftPillarJoints[i - 1], leftPillarJoint);
            addBeam(rightPillarJoints[i - 1], rightPillarJoint);
        }
    }

    // Conectar los pilares entre sí con vigas diagonales para formar triángulos
    for (let i = 0; i < leftPillarJoints.length - 1; i++) {
        addBeam(leftPillarJoints[i], rightPillarJoints[i]);
        addBeam(leftPillarJoints[i + 1], rightPillarJoints[i]);
        addBeam(leftPillarJoints[i], rightPillarJoints[i + 1]);
    }

    // Crear vigas adicionales entre los extremos superiores de los pilares y los joints A y B
    const jointA = addJoint([startX, centerY],'f');
    const jointB = addJoint([startX + length, centerY],'f');

    addBeam(jointA, leftPillarJoints[0]);
    addBeam(jointB, rightPillarJoints[0]);

    // Conectar los extremos inferiores de los pilares con los joints A y B
    addBeam(leftPillarJoints[leftPillarJoints.length - 1], jointA);
    addBeam(rightPillarJoints[rightPillarJoints.length - 1], jointB);

    // Añadir más beams entre los puntos de los pilares y los joints A y B
    for (let i = 1; i < leftPillarJoints.length - 1; i++) {
        addBeam(leftPillarJoints[i], jointA);
        addBeam(rightPillarJoints[i], jointB);
    }

    // Añadir los joints fixed en las posiciones especificadas
    const fixedJointBottomLeft = addJoint([centerX - pillarSeparation / 2, centerY + pillarHeight], 'f'); // Joint fixed abajo a la izquierda al inicio del pilar
    const fixedJointBottomRight = addJoint([centerX + pillarSeparation / 2, centerY + pillarHeight], 'f'); // Joint fixed abajo a la derecha al final del pilar

    return bridgeModel; // Devolver el modelo completo del puente
}


function createPrattBridge(bridgeLength) {
    // Limpiar juntas y vigas existentes
    bridgeModel.joints = [];
    bridgeModel.beams = [];

    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const centerX = windowWidth / 2;
    const centerY = windowHeight * 0.55;
    const startX = centerX - bridgeLength / 2;

    const Height = bridgeLength * 0.2; // Altura de los pilares centrales

    // Función para agregar una nueva junta si no existe
    function addJoint(position, type = 'null') {
        let existingJoint = bridgeModel.joints.find(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
        if (!existingJoint) {
            const newJoint = new Joint(renderEngine);
            newJoint.position = position;
            newJoint.jointType = type;
            bridgeModel.joints.push(newJoint);
            return newJoint;
        } else if (type === 'f') {
            existingJoint.jointType = type; // Actualizar la junta existente a fija si se necesita
        }
        return existingJoint;
    }

    // Función para agregar una nueva viga si no existe
    function addBeam(jointA, jointB) {
        if (!bridgeModel.beams.some(beam =>
            (beam.jointA === jointA && beam.jointB === jointB) ||
            (beam.jointA === jointB && beam.jointB === jointA)
        )) {
            const newBeam = new Beam(jointA, jointB);
            bridgeModel.beams.push(newBeam);
        }
    }

    // Crear juntas en los extremos inferiores
    const jointA = addJoint([startX, centerY], "f");
    const jointB = addJoint([startX + bridgeLength, centerY], "f");

    // Ajustar la separación de las vigas
    const vBeamSeparation = bridgeLength / 10; // Separación entre las vigas verticales

    // Crear vigas verticales y conectar con juntas horizontales
    const verticalBeams = [];
    for (let i = 1; i <= 10; i++) {
        const vBeamX = startX + i * vBeamSeparation;
        const vBeamJointA = addJoint([vBeamX, centerY]);
        const vBeamJointB = addJoint([vBeamX, centerY - Height]);

        // Conectar con vigas horizontales si no es la primera o última viga vertical
        if (i > 1 && i < 6) {
            const prevVBeamJointB = verticalBeams[verticalBeams.length - 1];
            addBeam(prevVBeamJointB, vBeamJointA);
        }

        addBeam(vBeamJointA, vBeamJointB);
        verticalBeams.push(vBeamJointB); // Añadir el joint B de la viga vertical al array
    }

    // Crear vigas horizontales y diagonales en Pratt
    for (let i = 0; i < verticalBeams.length - 1; i++) {
        const joint1 = verticalBeams[i];
        const joint2 = verticalBeams[i + 1];
        const joint3 = addJoint([startX + (i + 1) * vBeamSeparation, centerY]); // Joint horizontal arriba
        const joint4 = addJoint([startX + i * vBeamSeparation, centerY]); // Joint horizontal arriba

        // Determinar la dirección de las diagonales según la mitad izquierda o derecha del puente
        if (i < 4) {
            addBeam(joint1, joint3); // Diagonal izquierda hacia la izquierda en la mitad izquierda
        } else if (i > 4) {
            addBeam(joint1, joint4); // Diagonal derecha hacia la derecha en la mitad derecha
        }

        addBeam(joint1, joint2); // Viga horizontal entre dos joints verticales
    }

    // Conectar la carretera
    for (let i = 0; i < 10; i++) {
        const joint1 = addJoint([startX + i * vBeamSeparation, centerY]);
        const joint2 = addJoint([startX + (i + 1) * vBeamSeparation, centerY]);
        addBeam(joint1, joint2);
    }

    // Agregar vigas diagonales en los extremos
    const firstVerticalJointTop = addJoint([startX + vBeamSeparation, centerY - Height]);
    const lastVerticalJointTop = addJoint([startX + 9 * vBeamSeparation, centerY - Height]);

    addBeam(jointA, firstVerticalJointTop); // Diagonal desde jointA hacia la derecha
    addBeam(jointB, lastVerticalJointTop); // Diagonal desde jointB hacia la izquierda

    // Eliminar joints superiores correspondientes a jointA y jointB
// Eliminar el joint superior correspondiente a jointB
bridgeModel.joints = bridgeModel.joints.filter(joint => 
    !(joint.position[0] === startX + 10 * vBeamSeparation && joint.position[1] === centerY - Height)
);

// Eliminar los beams que involucran al joint superior de jointB
bridgeModel.beams = bridgeModel.beams.filter(beam =>
    !(
        (beam.jointA.position[0] === startX + 10 * vBeamSeparation && beam.jointA.position[1] === centerY - Height) ||
        (beam.jointB.position[0] === startX + 10 * vBeamSeparation && beam.jointB.position[1] === centerY - Height)
    )
);
    return bridgeModel; // Devolver el modelo puente
}


function generateBridge() {
    const distance = prompt("Please enter the distance for the bridge (m):");
    const option = prompt("Choose bridge design option:\n1. Pratt design \n2. Warren design\n3. Arch design\n4. Brown design\n5. Invented design");

    if (distance && !isNaN(distance)) {
        const bridgeLength = Math.round(parseFloat(distance) * 24); // Convertir metros a unidades de 24 (1m en unidades) y redondear
        
        if (option === '1') {
            createPrattBridge(bridgeLength);
        } else if (option === '2') {
            createStableBridge2(bridgeLength);
        } else if (option === '3') {
            createArchBridge(bridgeLength);
        } else if (option === '4') {
            createStableBridge(bridgeLength);
        } else if (option === '5') {
            createDoublePillarBridge(bridgeLength);
        } else {
            alert("Invalid option. Please choose 1, 2, 3 , 4 or 5.");
            return;
        }

        render();
    } else {
        alert("Invalid distance. Please enter a valid number.");
    }
}

















function checkStability() {
    const MAX_BEAM_STRESS = 250000000; // Pa (N/m²)
    const BEAM_WEIGHT_PER_M = 141; // kg/m
    const GRAVITY = 9.81; // m/s²
    const FORCE_TOLERANCE = 1; // Tolerancia de fuerza para equilibrio
    const SLENDERNESS_LIMIT = 200; // Ratio de esbeltez límite para vigas de acero
    const MAX_BEAM_LENGTH = 400; // Longitud máxima permisible para una viga 
    const MAX_BEAM_MOMENT = 50000000; // N·m, momento máximo permisible
    const MIN_ANGLE = 10; // Grados, ángulo mínimo permisible entre vigas
    const MAX_ANGLE = 170; // Grados, ángulo máximo permisible entre vigas

    // Constantes adicionales
    const VEHICLE_WEIGHT = 15000; // kg, peso camion
    const PEDESTRIAN_DENSITY = 1.5; // personas por m²
    const PEDESTRIAN_WEIGHT = 75; // kg, peso promedio de una persona
    const WIND_LOAD = 300; // N/m², carga de viento
    const Y_MAX = 0.07; // Distancia máxima al eje neutro (m) para IPN 500
    const E = 210000000000; // Módulo de elasticidad para el acero (Pa)
    const I = 1.93e-5; // Momento de inercia (m^4) para IPN 500

    let joints = bridgeModel.joints;
    let beams = bridgeModel.beams;
    let stable = true;
    let fixedJointCount = 0;
    let totalFx = 0;
    let totalFy = 0;

    // Inicializar fuerzas en los nudos y calcular conexiones
    joints.forEach(joint => {
        joint.force = [0, 0];
        joint.moment = 0;
        joint.connectedBeams = beams.filter(beam => beam.jointA === joint || beam.jointB === joint);
        if (joint.jointType === 'f') {
            fixedJointCount++;
        }
    });

    // Verificar que cada nudo esté conectado por al menos dos beams
    joints.forEach(joint => {
        if (joint.connectedBeams.length < 2) {
            console.log(`Joint at position (${joint.position[0]}, ${joint.position[1]}) is not connected by at least two beams.`);
            stable = false;
        }
    });

    if (!stable) {
        alert("The bridge is not stable: Some joints are not connected by at least two beams.");
        return false;
    }

    // Verificar que haya al menos dos nudos fijos
    if (fixedJointCount < 2) {
        alert("The bridge is not stable: At least two fixed joints are required.");
        return false;
    }

    // Variables para verificar la presencia de triángulos y longitudes de vigas
    let irrationalShapes = false;

    // Calcular fuerzas y momentos en cada beam y distribuirlas a los nudos
    beams.forEach(beam => {
        let jointA = beam.jointA;
        let jointB = beam.jointB;

        let dx = (jointB.position[0] - jointA.position[0]) / 1000; // mm -> m
        let dy = (jointB.position[1] - jointA.position[1]) / 1000; // mm -> m
        let length = Math.sqrt(dx * dx + dy * dy);
        let weight = length * BEAM_WEIGHT_PER_M; // Peso del beam
        let force = weight * GRAVITY; // Convertir el peso en fuerza (N)
        
        // Fuerza por peso añadido de vehículos
        let vehicleForce = (VEHICLE_WEIGHT * GRAVITY) / beams.length;
        force += vehicleForce;

        // Fuerza por peso añadido de peatones
        let pedestrianLoad = PEDESTRIAN_DENSITY * PEDESTRIAN_WEIGHT * GRAVITY; // N/m²
        force += pedestrianLoad * length;

        // Fuerza por carga de viento
        let windForce = WIND_LOAD * length;
        let windFx = windForce * (dy / length); // Componente de fuerza del viento en x
        let windFy = windForce * (dx / length); // Componente de fuerza del viento en y

        // Verificar longitud del beam
        if (length * 1000 > MAX_BEAM_LENGTH) {
            console.log(`Beam between (${jointA.position[0]}, ${jointA.position[1]}) and (${jointB.position[0]}, ${jointB.position[1]}) is too long: ${length * 1000} mm`);
            irrationalShapes = true;
        }

        // Verificar esbeltez del beam
        let slenderness = length / 0.0704; // Radio de giro (m)
        if (slenderness > SLENDERNESS_LIMIT) {
            console.log(`Beam between (${jointA.position[0]}, ${jointA.position[1]}) and (${jointB.position[0]}, ${jointB.position[1]}) has a high slenderness ratio: ${slenderness}`);
            stable = false;
        }

        // Calcular momento en el beam
        let uniformLoad = force / length; // q, carga uniforme por unidad de longitud
        let maxMoment = (uniformLoad * length * length) / 8; // Momento máximo en el centro del beam

        // Calcular tensión máxima en el beam
        let maxStress = (Y_MAX * uniformLoad * length * length) / (8 * I); // Tensión máxima

        // Calcular deflexión máxima en el beam
        let maxDeflection = (5 * uniformLoad * Math.pow(length, 4)) / (384 * E * I); // Deflexión máxima

        // Distribuir fuerzas y momentos entre los nudos conectados por el beam
        jointA.force[0] += windFx;
        jointA.force[1] += windFy + uniformLoad * length / 2;
        jointA.moment += maxMoment / 2; // Distribuir la mitad del momento en cada nudo
        jointB.force[0] -= windFx;
        jointB.force[1] -= windFy + uniformLoad * length / 2;
        jointB.moment += maxMoment / 2;

        // Verificar si la tensión o el momento exceden los límites permisibles
        if (maxStress > MAX_BEAM_STRESS) {
            console.log(`Beam between (${jointA.position[0]}, ${jointA.position[1]}) and (${jointB.position[0]}, ${jointB.position[1]}) has stress ${maxStress} Pa which exceeds the limit of ${MAX_BEAM_STRESS} Pa`);
            stable = false;
        }

        if (maxMoment > MAX_BEAM_MOMENT) {
            console.log(`Beam between (${jointA.position[0]}, ${jointA.position[1]}) and (${jointB.position[0]}, ${jointB.position[1]}) has moment ${maxMoment} N·m which exceeds the limit of ${MAX_BEAM_MOMENT} N·m`);
            stable = false;
        }

        // Verificar la deflexión máxima
        if (maxDeflection > length / 200) { // Límite arbitrario para la deflexión
            console.log(`Beam between (${jointA.position[0]}, ${jointA.position[1]}) and (${jointB.position[0]}, ${jointB.position[1]}) has deflection ${maxDeflection} m which exceeds the allowable limit`);
            stable = false;
        }

        // Verificar que los beams no estén alineados en línea recta sin soporte intermedio
        if (isCollinear(jointA, jointB) && jointA.connectedBeams.length == 2 && jointB.connectedBeams.length == 2) {
            console.log(`Beams connected by joint at (${jointA.position[0]}, ${jointA.position[1]}) and (${jointB.position[0]}, ${jointB.position[1]}) are in a straight line without intermediate support.`);
            stable = false;
        }
    });

    // Verificar la presencia de triángulos y ángulos entre vigas
    let triangles = findTriangles(joints, beams);
    triangles.forEach(triangle => {
        let jointA = triangle[0];
        let jointB = triangle[1];
        let jointC = triangle[2];
        
        let angleAB_AC = calculateAngle(jointA, jointB, jointC);
        let angleBA_BC = calculateAngle(jointB, jointA, jointC);
        let angleCA_CB = calculateAngle(jointC, jointA, jointB);

        if (angleAB_AC < MIN_ANGLE || angleAB_AC > MAX_ANGLE || angleBA_BC < MIN_ANGLE || angleBA_BC > MAX_ANGLE || angleCA_CB < MIN_ANGLE || angleCA_CB > MAX_ANGLE) {
            console.log(`The bridge has a triangle with irrational angles: ${angleAB_AC}, ${angleBA_BC}, ${angleCA_CB}`);
            irrationalShapes = true;
        }
    });

    // Verificar el equilibrio de fuerzas en el sistema completo
    joints.forEach(joint => {
        totalFx += joint.force[0];
        totalFy += joint.force[1];
    });

    if (Math.abs(totalFx) > FORCE_TOLERANCE || Math.abs(totalFy) > FORCE_TOLERANCE) {
        console.log(`The bridge is not in equilibrium: Total Fx = ${totalFx.toFixed(3)}, Total Fy = ${totalFy.toFixed(3)}`);
        stable = false;
    }

    // Si todas las verificaciones pasaron, el puente es estable
    if (stable) {
        alert("The bridge probably is stable.");
    } else {
        alert("The bridge may not be stable: Check console for detailed instability reasons.");
    }

    if (irrationalShapes) {
        alert("The bridge has some beams that are too long or form irrational shapes.");
    }

    console.log("Stability check completed. Stable:", stable);


    return stable;
}

// Función para verificar si tres nudos están alineados en línea recta
function isCollinear(jointA, jointB) {
    let beamA = jointA.connectedBeams[0];
    let beamB = jointA.connectedBeams[1];
    let jointC = beamA.jointA === jointA ? beamA.jointB : beamA.jointA;
    let jointD = beamB.jointA === jointA ? beamB.jointB : beamB.jointA;

    return (jointB.position[0] - jointA.position[0]) * (jointD.position[1] - jointA.position[1]) === (jointD.position[0] - jointA.position[0]) * (jointB.position[1] - jointA.position[1]);
}

// Función para encontrar triángulos en la estructura
function findTriangles(joints, beams) {
    let triangles = [];
    
   
    function beamExists(jointA, jointB) {
        return beams.some(beam => 
            (beam.jointA === jointA && beam.jointB === jointB) || 
            (beam.jointA === jointB && beam.jointB === jointA)
        );
    }
    

    for (let i = 0; i < joints.length; i++) {
        for (let j = i + 1; j < joints.length; j++) {
            for (let k = j + 1; k < joints.length; k++) {
                const jointA = joints[i];
                const jointB = joints[j];
                const jointC = joints[k];
                

                if (beamExists(jointA, jointB) && beamExists(jointB, jointC) && beamExists(jointC, jointA)) {
                    triangles.push([jointA, jointB, jointC]);
                }
            }
        }
    }

    return triangles;
}

// Función para calcular el ángulo entre tres nodos
function calculateAngle(jointA, jointB, jointC) {
    let dx1 = jointB.position[0] - jointA.position[0];
    let dy1 = jointB.position[1] - jointA.position[1];
    let dx2 = jointC.position[0] - jointA.position[0];
    let dy2 = jointC.position[1] - jointA.position[1];

    let dotProduct = dx1 * dx2 + dy1 * dy2;
    let magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
    let magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

    let angleRad = Math.acos(dotProduct / (magnitude1 * magnitude2));
    let angleDeg = angleRad * (180 / Math.PI);
    
    return angleDeg;
}































function distributeTruckLoad(centerIndex, initialLoad) {
    const visitedBeams = new Set();
    const visitedJoints = new Set();

    const centerBeam = bridgeModel.beams[centerIndex];
    distributeLoad(centerBeam, initialLoad, visitedBeams, visitedJoints, 0);

    return initialLoad;
}

function distributeLoad(beam, load, visitedBeams = new Set(), visitedJoints = new Set(), depth = 0) {
    if (visitedBeams.has(beam) || load < 1) return;
    visitedBeams.add(beam);

    // Calcular el peso propio de la viga
    const dx = (beam.jointB.position[0] - beam.jointA.position[0]) / 1000; // mm -> m
    const dy = (beam.jointB.position[1] - beam.jointA.position[1]) / 1000; // mm -> m
    const length = Math.sqrt(dx * dx + dy * dy);
    const weight = length * 141 * 9.81; // Peso del beam (N)

    // Añadir el peso propio de la viga a la carga aplicada
    const totalLoad = load + weight;

    // Distribuir la carga a las juntas conectadas
    distributeLoadToJoint(beam.jointA, totalLoad / 2, visitedJoints, depth);
    distributeLoadToJoint(beam.jointB, totalLoad / 2, visitedJoints, depth);

    // Obtener los beams conectados a las juntas de este beam
    const connectedBeams = getConnectedBeams(beam);

    // Aumentar la carga a medida que nos alejamos de los puntos fijos
    const increasedLoad = totalLoad * (1 + depth * 0.1); // Incremento del 10% por nivel de profundidad
    const distributedLoad = increasedLoad / connectedBeams.length;

    // Distribuir carga a los beams conectados
    connectedBeams.forEach(connectedBeam => {
        distributeLoad(connectedBeam, distributedLoad, visitedBeams, visitedJoints, depth + 1);
    });
}

function distributeLoadToJoint(joint, load, visitedJoints, depth) {
    if (visitedJoints.has(joint) || load < 1) return;
    visitedJoints.add(joint);
    if (joint.type !== 'f') {
        // Aumentar la carga a medida que nos alejamos de los puntos fijos
        joint.appliedLoad += load * (1 + depth * 0.1); // Incremento del 10% por nivel de profundidad
    }
}

function getConnectedBeams(beam) {
    const connectedBeams = [];
    bridgeModel.beams.forEach(b => {
        if (b !== beam && (b.jointA === beam.jointA || b.jointA === beam.jointB || b.jointB === beam.jointA || b.jointB === beam.jointB)) {
            connectedBeams.push(b);
        }
    });
    return connectedBeams;
}

function simulateWithAdditionalLoads(centerIndex, truckLoad) {
    for (let i = 0; i < bridgeModel.beams.length; i++) {
        if (i !== centerIndex) {
            const beam = bridgeModel.beams[i];
            const additionalLoad = Math.random() * truckLoad * 0.5; // Carga adicional aleatoria
            distributeLoad(beam, additionalLoad);
        }
    }
}

function calculateBeamStressesAndMoments() {
    const beams = bridgeModel.beams;
    let maxStress = 0;

    // Parámetros de perfil estructural
    const Y_MAX = 0.25; // Distancia máxima al eje neutro (m)
    const E = 210000000000; // Módulo de elasticidad para el acero (Pa)
    const I = 8.9e-5; // Momento de inercia (m^4)
    const BEAM_WEIGHT_PER_M = 141; // Peso del beam (kg/m)

    beams.forEach(beam => {
        const jointA = beam.jointA;
        const jointB = beam.jointB;

        const dx = (jointB.position[0] - jointA.position[0]) / 1000; // mm -> m
        const dy = (jointB.position[1] - jointA.position[1]) / 1000; // mm -> m
        const length = Math.sqrt(dx * dx + dy * dy);
        const weight = length * BEAM_WEIGHT_PER_M; // Peso del beam
        let force = weight * 9.81; // Convertir el peso en fuerza (N)

        // Añadir la carga aplicada del camión
        if (beam.appliedLoad) {
            force += beam.appliedLoad;
        }

        // Calcular carga uniforme por unidad de longitud (N/m)
        const uniformLoad = force / length;

        // Calcular momento máximo en el beam
        const maxMomentInBeam = (uniformLoad * length * length) / 8; // Momento máximo en el centro del beam

        // Calcular tensión máxima en el beam
        const maxStressInBeam = (Y_MAX * uniformLoad * length * length) / (8 * I); // Tensión máxima

        beam.stress = maxStressInBeam;
        beam.moment = maxMomentInBeam;

        if (beam.stress > maxStress) {
            maxStress = beam.stress + 10000;
        }
    });

    return { maxStress };
}

function evaluateBridgeStability(maxStress) {
    const unstableJoints = [];
    bridgeModel.joints.forEach(joint => {
        // Evaluar si la carga aplicada en las juntas excede el umbral de estabilidad basado en las tensiones máximas de las vigas
        if (joint.appliedLoad > maxStress) {
            unstableJoints.push(joint);
        }
    });

    return {
        isStable: unstableJoints.length === 0,
        unstableJoints
    };
}

function simulateAndRenderBridge() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const joints = bridgeModel.joints;
    const beams = bridgeModel.beams;

    // Calcular tensiones y momentos actualizados
    const { maxStress } = calculateBeamStressesAndMoments();

    // Definir colores para la escala
    const green = [0, 255, 0];
    const red = [255, 0, 0];

    // Función para interpolar entre dos colores
    function interpolateColor(color1, color2, factor) {
        const result = color1.slice();
        for (let i = 0; i < 3; i++) {
            result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
        }
        return `rgb(${result[0]},${result[1]},${result[2]})`;
    }

    // Dibujar juntas y resaltar según la carga aplicada
    joints.forEach(joint => {
        let color;
        if (joint.type === 'f') {
            color = 'green'; // Juntas fijas en verde
        } else {
            const factor = Math.min(joint.appliedLoad / maxStress, 1);
            color = interpolateColor(green, red, factor);
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(joint.position[0], joint.position[1], 5, 0, Math.PI * 2);
        ctx.fill();
    });

    // Dibujar vigas y resaltar según la tensión
    beams.forEach(beam => {
        const factor = Math.min(beam.stress / maxStress, 1);
        const color = interpolateColor(green, red, factor);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(beam.jointA.position[0], beam.jointA.position[1]);
        ctx.lineTo(beam.jointB.position[0], beam.jointB.position[1]);
        ctx.stroke();
    });

    // Dibujar texto informativo
    ctx.fillStyle = 'black';
    ctx.font = '20px Arial';
    ctx.fillText('Weaknesses:', 10, 20);
}

function redistributeLoadFromOverloadedBeams() {
    const { maxStress } = calculateBeamStressesAndMoments(); // Asegúrate de que maxStress esté definido aquí
    const overloadedBeams = bridgeModel.beams.filter(beam => beam.stress > maxStress);

    overloadedBeams.forEach(beam => {
        const connectedBeams = getConnectedBeams(beam);
        if (connectedBeams.length > 0) {
            const additionalLoad = beam.stress - maxStress; // Carga adicional a redistribuir
            const loadPerBeam = additionalLoad / connectedBeams.length;

            connectedBeams.forEach(connectedBeam => {
                distributeLoad(connectedBeam, loadPerBeam);
            });
        }
    });
}

function simulateWithTruck() {
    const centerIndex = Math.floor(bridgeModel.beams.length / 2);
    const initialLoad = 100000; // Carga inicial de 100kN (10 toneladas)

    // Limpiar cargas anteriores
    bridgeModel.beams.forEach(beam => {
        beam.appliedLoad = 0;
    });

    bridgeModel.joints.forEach(joint => {
        joint.appliedLoad = 0;
    });

    // Aplicar y distribuir la carga inicial
    distributeTruckLoad(centerIndex, initialLoad);

    // Evaluar y redistribuir cargas
    redistributeLoadFromOverloadedBeams();

    simulateAndRenderBridge();
}










const ANIMATION_SPEED = 0.01; // Velocidad de la animación 
const FRAME_RATE = 60   ; // Tasa de frames por segundo
const FRAME_INTERVAL = 1000 / FRAME_RATE; // Intervalo entre frames en ms
const ANIMATION_DURATION = 5000; // Duración de la animación en ms (5 segundos)
const SQUARE_SIZE = 10; // Tamaño del cuadrado que representa la carga
const BEAM_WIDTH = 0.1; // Ancho del beam en metros
const ADDED_LOAD = 100000; // Carga añadida en N para los beams por los que pasa el cuadrado (10 toneladas)
const STRENGTH_LIMIT1 = 90000; // Límite de resistencia para la coloración
const UPDATE_INTERVAL = 50; // Intervalo de actualización en ms

let startTime; // Hora de inicio de la animación
let currentBeam; // Beam actual en el que se encuentra el cuadrado
let currentPosition = 0; // Posición del cuadrado en metros dentro del beam
let lastUpdateTime = 0; // tiempo del último cambio en la carga

function distanceToLine(px, py, ax, ay, bx, by) {
    const A = px - ax;
    const B = py - ay;
    const C = bx - ax;
    const D = by - ay;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    const param = dot / len_sq;
    let xx, yy;
    if (param < 0) {
        xx = ax;
        yy = ay;
    } else if (param > 1) {
        xx = bx;
        yy = by;
    } else {
        xx = ax + param * C;
        yy = ay + param * D;
    }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function findClosestBeamToPosition(x, y) {
    let closestBeam = null;
    let minDistance = Infinity;

    bridgeModel.beams.forEach(beam => {
        const distance = distanceToLine(x, y, beam.jointA.position[0], beam.jointA.position[1], beam.jointB.position[0], beam.jointB.position[1]);
        if (distance < minDistance) {
            minDistance = distance;
            closestBeam = beam;
        }
    });

    return closestBeam;

}

function calculateDistanceToClosestFixedJoint(x, y) {
    const fixedJoints = bridgeModel.joints.filter(joint => joint.jointType === 'f');
    let minDistance = Infinity;
    fixedJoints.forEach(fixedJoint => {
        const dx = x - fixedJoint.position[0];
        const dy = y - fixedJoint.position[1];
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < minDistance) {
            minDistance = distance;
        }
    });
    return minDistance;
}

function updateAllBeamsLoad() {
    bridgeModel.beams.forEach(beam => {
        if (beam.appliedLoad === undefined) {
            beam.appliedLoad = 0;
        }
    });
}
function distributeLoadToAdjacentBeams(beam, x, y, depth = 0, maxDepth = 5, attenuationFactor = 0.1) {
    if (depth > maxDepth) return; // Detener si se ha alcanzado la profundidad máxima

    const connectedBeamsA = getConnectedBeamsFromJoint(beam.jointA);
    const connectedBeamsB = getConnectedBeamsFromJoint(beam.jointB);
    const connectedBeams = connectedBeamsA.concat(connectedBeamsB);

    const distanceToFixedJoint = calculateDistanceToClosestFixedJoint(x, y);
    const loadIncreaseFactor = distanceToFixedJoint / 100; // Ajuste según sea necesario para escalar la carga
    const loadPerBeam = (ADDED_LOAD * loadIncreaseFactor * Math.pow(attenuationFactor, depth)) / (connectedBeams.length + 1); // +1 para incluir el beam actual

    connectedBeams.forEach(connectedBeam => {
        if (connectedBeam !== beam) {
            if (connectedBeam.appliedLoad === undefined) {
                connectedBeam.appliedLoad = 0;
            }
            connectedBeam.appliedLoad += loadPerBeam;

            // Distribuir la carga a los beams adyacentes
            distributeLoadToAdjacentBeams(connectedBeam, x, y, depth + 1, maxDepth, attenuationFactor);
        }
    });

    if (beam.appliedLoad === undefined) {
        beam.appliedLoad = 0;
    }
    beam.appliedLoad += loadPerBeam; // Aplicar la carga restante al beam actual
}


function recordOriginalBeamColors() {
    bridgeModel.beams.forEach(beam => {
        beam.originalColor = beam.color;
    });
}

function restoreOriginalColor(beam) {
    if (beam.originalColor) {
        beam.color = beam.originalColor;
    }
}

function applyInitialLoad(load) {
    bridgeModel.beams.forEach(beam => {
        if (beam.appliedLoad === undefined) {
            beam.appliedLoad = 0;
        }
        beam.appliedLoad = load; // Aplicar carga inicial
    });
}

function simulateWithTruck5(startJoint, endJoint, duration) {
    const totalDistance = Math.sqrt(
        Math.pow(endJoint.position[0] - startJoint.position[0], 2) +
        Math.pow(endJoint.position[1] - startJoint.position[1], 2)
    );

    const animationStartTime = Date.now();
    let lastBeam = null;
    let lastBeamChangeTime = Date.now();
    const BEAM_CHANGE_THRESHOLD = 2500; // Tiempo en ms para detectar un cambio de beam (10 segundos)

    function animateTruck() {
        const elapsedTime = Date.now() - animationStartTime;
        const t = Math.min(elapsedTime / duration, 1);
        const x = startJoint.position[0] + t * (endJoint.position[0] - startJoint.position[0]);
        const y = startJoint.position[1] + t * (endJoint.position[1] - startJoint.position[1]);

        const closestBeam = findClosestBeamToPosition(x, y);

        if (closestBeam) {
            if (closestBeam !== lastBeam) {
                // El beam ha cambiado
                distributeLoadToAdjacentBeams(closestBeam, x, y);
                lastBeam = closestBeam;
                lastBeamChangeTime = Date.now();
            } else if (Date.now() - lastBeamChangeTime > BEAM_CHANGE_THRESHOLD) {
                // Si ha pasado mucho tiempo en el mismo beam es que el puente tiene demasiados pocos beams por lo tanto es probable qu no sea estable

                alert('A lot of loops, the bridge may not be stable');
            }

            // Actualizar la carga
            updateLoad();

            // Renderizar el puente
            simulateAndRenderBridge1();
        } else {
            console.error('Closest beam is undefined.');
        }

        if (t < 1) {
            setTimeout(animateTruck, FRAME_INTERVAL);
        } else {
            console.log('Finished');
        }
    }

    animateTruck();
}



function updateLoad() {
    const now = Date.now();
    const timeElapsed = now - lastUpdateTime;
    if (timeElapsed >= UPDATE_INTERVAL) {
        bridgeModel.beams.forEach(beam => {
            if (beam.appliedLoad !== undefined) {
                const reductionFactor = ADDED_LOAD * (timeElapsed / 1000); // Ajuste de la reducción por segundo
                beam.appliedLoad = Math.max(0, beam.appliedLoad - reductionFactor);
            }
        });
        lastUpdateTime = now;
    }
}


function interpolateColor2(color1, color2, factor) {
    const r = Math.floor(color1[0] + factor * (color2[0] - color1[0]));
    const g = Math.floor(color1[1] + factor * (color2[1] - color1[1]));
    const b = Math.floor(color1[2] + factor * (color2[2] - color1[2]));
    return `rgb(${r}, ${g}, ${b})`;
}

function getBeamColor(beam) {
    if (beam.appliedLoad === undefined) {
        return 'green';
    }

    const loadRatio = beam.appliedLoad / STRENGTH_LIMIT1;
    const factor = Math.min(loadRatio, 1);

    // Definir colores de gradiente
    const colors = [
        [0, 255, 0],   // Verde
        [255, 255, 0], // Amarillo
        [255, 165, 0], // Naranja
        [255, 0, 0]    // Rojo
    ];

    // Determinar el rango de colores para la carga actual
    const numColors = colors.length;
    const segment = 1 / (numColors - 1);
    let color1 = colors[0];
    let color2 = colors[1];
    let segmentIndex = 0;

    for (let i = 1; i < numColors; i++) {
        if (factor <= segment * i) {
            color1 = colors[i - 1];
            color2 = colors[i];
            segmentIndex = i - 1;
            break;
        }
    }

    const localFactor = (factor - segment * segmentIndex) / segment;
    return interpolateColor2(color1, color2, localFactor);
}


function updateBeamColor(beam) {
    beam.color = getBeamColor(beam);
}
function getConnectedBeamsFromJoint(joint) {
    return bridgeModel.beams.filter(beam =>
        beam.jointA === joint || beam.jointB === joint
    );
}


function animateBridge() {


    
    const fixedJoints = bridgeModel.joints.filter(joint => joint.jointType === 'f');
    if (fixedJoints.length < 2) {
        console.error('At least 2 joint fixed needed.');
        return;
    }

    const startJoint = fixedJoints[0];
    const endJoint = fixedJoints[fixedJoints.length - 1];
    const totalDistance = Math.sqrt(
        Math.pow(endJoint.position[0] - startJoint.position[0], 2) +
        Math.pow(endJoint.position[1] - startJoint.position[1], 2)
    );

    startTime = Date.now();
    currentBeam = findClosestBeamToPosition(startJoint.position[0], startJoint.position[1]);
    simulateWithTruck5(startJoint, endJoint, ANIMATION_DURATION);

    recordOriginalBeamColors(); // Registrar colores originales al inicio

    function animate() {
        const elapsedTime = Date.now() - startTime;
        if (elapsedTime < ANIMATION_DURATION) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const t = Math.min(elapsedTime / ANIMATION_DURATION, 1);
            const x = startJoint.position[0] + t * (endJoint.position[0] - startJoint.position[0]);
            const y = startJoint.position[1] + t * (endJoint.position[1] - startJoint.position[1]);

            const closestBeam = findClosestBeamToPosition(x, y);

            if (currentBeam !== closestBeam) {
                restoreOriginalColor(currentBeam);
                currentBeam = closestBeam;
                currentPosition = 0;
            }

            const beamStartX = currentBeam.jointA.position[0];
            const beamStartY = currentBeam.jointA.position[1];
            const beamEndX = currentBeam.jointB.position[0];
            const beamEndY = currentBeam.jointB.position[1];
            const beamLength = Math.sqrt(Math.pow(beamEndX - beamStartX, 2) + Math.pow(beamEndY - beamStartY, 2));
            currentPosition = (t * totalDistance) % beamLength;

            const beamProgress = currentPosition / beamLength;
            const squareX = beamStartX + beamProgress * (beamEndX - beamStartX);
            const squareY = beamStartY + beamProgress * (beamEndY - beamStartY);

            ctx.fillStyle = 'blue';
            ctx.fillRect(squareX - SQUARE_SIZE / 2, squareY - SQUARE_SIZE / 2, SQUARE_SIZE, SQUARE_SIZE);

            updateAllBeamsLoad();
            updateLoad(); // Asegurando la disminución gradual de la carga
            bridgeModel.beams.forEach(updateBeamColor);

            simulateAndRenderBridge1();

            setTimeout(animate, FRAME_INTERVAL);
        } else {
            // Al finalizar la animación, asegurar la restauración completa
            restoreOriginalColor(currentBeam);
        }
    }

    animate();
}   


    


function simulateAndRenderBridge1() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const joints = bridgeModel.joints;
    const beams = bridgeModel.beams;

    // Calcular tensiones y momentos actualizados
    calculateBeamStressesAndMoments();

    // Dibujar juntas y resaltar según la carga aplicada
    joints.forEach(joint => {
        let color;
        if (joint.jointType === 'f') {
            color = 'black'; // Juntas fijas en verde
        } else {
            const factor = Math.min(joint.appliedLoad / STRENGTH_LIMIT1, 1);
            color = interpolateColor2([0, 255, 0], [255, 0, 0], factor);
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(joint.position[0], joint.position[1], 5, 0, Math.PI * 2);
        ctx.fill();
    });

    // Dibujar vigas y resaltar según la tensión
    beams.forEach(beam => {
        const factor = beam.broken ? 1 : Math.min(beam.stress / STRENGTH_LIMIT1, 1);
        const color = getBeamColor(beam);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(beam.jointA.position[0], beam.jointA.position[1]);
        ctx.lineTo(beam.jointB.position[0], beam.jointB.position[1]);
        ctx.stroke();
    });

    // Dibujar el cuadrado que representa la carga
    if (currentBeam) {
        const beamStartX = currentBeam.jointA.position[0];
        const beamStartY = currentBeam.jointA.position[1];
        const beamEndX = currentBeam.jointB.position[0];
        const beamEndY = currentBeam.jointB.position[1];
        const beamLength = Math.sqrt(Math.pow(beamEndX - beamStartX, 2) + Math.pow(beamEndY - beamStartY, 2));
        const beamProgress = currentPosition / beamLength;
        const squareX = beamStartX + beamProgress * (beamEndX - beamStartX);
        const squareY = beamStartY + beamProgress * (beamEndY - beamStartY);
        ctx.fillStyle = 'blue';
        ctx.fillRect(squareX - SQUARE_SIZE / 2, squareY - SQUARE_SIZE / 2, SQUARE_SIZE, SQUARE_SIZE);
    }

    // Dibujar texto informativo
    ctx.fillStyle = 'black';
    ctx.font = '20px Arial';
    ctx.fillText('Simulated Bridge:', 10, 20);
}








// Historial de acciones
let history = {
    undoStack: [],
    redoStack: [],
    addActionToHistory: function(action) {
        this.undoStack.push(action);
        this.redoStack = []; // Limpiar la pila de redo al agregar una nueva acción
    },
    undo: function() {
        if (this.undoStack.length > 0) {
            let action = this.undoStack.pop();
            action.undo(); // Llamar al método undo de la acción
            this.redoStack.push(action); // Agregar a la pila de redo
        }
    },
    redo: function() {
        if (this.redoStack.length > 0) {
            let action = this.redoStack.pop();
            action.redo(); // Llamar al método redo de la acción
            this.undoStack.push(action); // Agregar de nuevo a la pila de undo
        }
    }
};

// Función  para deshacer una acción
function undo() {
    history.undo(); // Llamar a la función undo del historial
    render(); // Renderizar la aplicación después de deshacer la acción
}

// Función o para rehacer una acción
function redo() {
    history.redo(); // Llamar a la función redo del historial
    render(); // Renderizar la aplicación después de rehacer la acción
}




class AddJointAction {
    constructor(joint) {
        this.joint = joint;
    }

    undo() {
        // Eliminar la junta
        const index = bridgeModel.joints.indexOf(this.joint);
        if (index > -1) {
            bridgeModel.joints.splice(index, 1);
            console.log("undo add j")
        }
    }

    redo() {
        // Agregar la junta
        bridgeModel.joints.push(this.joint);
        console.log("redo add j")
    }
}

class RemoveJointAction {
    constructor(joint) {
        this.joint = joint;
    }

    undo() {
        // Reagregar la junta
        bridgeModel.joints.push(this.joint);
        console.log("undo rem j")
    }

    redo() {
        // Eliminar la junta
        const index = bridgeModel.joints.indexOf(this.joint);
        if (index > -1) {
            bridgeModel.joints.splice(index, 1);
            console.log("redo rem j")

        }
    }
}

class AddBeamAction {
    constructor(beam) {
        this.beam = beam;
    }

    undo() {
        // Eliminar la viga
        const index = bridgeModel.beams.indexOf(this.beam);
        if (index > -1) {
            bridgeModel.beams.splice(index, 1);
            console.log("undo add b")
        }
    }

    redo() {
        // Agregar la viga
        bridgeModel.beams.push(this.beam);
        console.log("redo add b")
    }
}

class RemoveSelectionAction {
    constructor(joints, beams) {
        this.joints = joints;
        this.beams = beams;
    }

    undo() {
        // Reagregar juntas y vigas
        bridgeModel.joints.push(...this.joints);
        bridgeModel.beams.push(...this.beams);
        console.log("undo rem s")
    }

    redo() {
        // Eliminar juntas y vigas
        this.joints.forEach(joint => {
            const index = bridgeModel.joints.indexOf(joint);
            if (index > -1) {
                bridgeModel.joints.splice(index, 1);
            }
        });

        this.beams.forEach(beam => {
            const index = bridgeModel.beams.indexOf(beam);
            if (index > -1) {
                bridgeModel.beams.splice(index, 1);
            }
        });
        console.log("redo rem s")
    }
}





function addJoint(position, type = 'null') {
    let existingJoint = bridgeModel.joints.find(joint => joint.position[0] === position[0] && joint.position[1] === position[1]);
    if (!existingJoint) {
        const newJoint = new Joint(renderEngine);
        newJoint.position = position;
        newJoint.jointType = type;
        bridgeModel.joints.push(newJoint);
        return newJoint;
    } else if (type === 'f') {
        existingJoint.jointType = type; // Actualizar la junta existente a fija si se necesita
    }
    return existingJoint;
}

// Función para agregar una nueva viga si no existe
function addBeam(jointA, jointB) {
    if (!bridgeModel.beams.some(beam =>
        (beam.jointA === jointA && beam.jointB === jointB) ||
        (beam.jointA === jointB && beam.jointB === jointA)
    )) {
        const newBeam = new Beam(jointA, jointB);
        bridgeModel.beams.push(newBeam);
    }
}

// Función para convertir joints y beams en una cadena de texto
function serializeBridge() {
    const joints = bridgeModel.joints.map(joint => `(${joint.position[0]}, ${joint.position[1]})`).join('\n');
    const beams = bridgeModel.beams.map(beam => `(${beam.jointA.position[0]}, ${beam.jointA.position[1]}) to (${beam.jointB.position[0]}, ${beam.jointB.position[1]})`).join('\n');
    return `Joints:\n${joints}\n\nBeams:\n${beams}`;
}

// Función para copiar la información del puente al portapapeles
function copyBridge() {
    const serializedData = serializeBridge();
    // Usar el prompt para mostrar la información copiada y también copiar al portapapeles
    const copyText = prompt("Copy coords of the bridge: ", serializedData);
    if (copyText) {
        navigator.clipboard.writeText(serializedData).then(() => {
            alert('Puente copiado al portapapeles.');
        }).catch(err => {
            console.error('Error:', err);
        });
    }
}

// Función para analizar una cadena de texto y crear joints y beams
function parseBridge(data) {
    const lines = data.trim().split('\n');
    const joints = [];
    const beams = [];

    let parsingBeams = false;

    lines.forEach(line => {
        if (line.startsWith('Joints:')) {
            parsingBeams = false;
        } else if (line.startsWith('Beams:')) {
            parsingBeams = true;
        } else {
            if (!parsingBeams) {
                // Analizar y agregar joints
                const [x, y] = line.replace(/[()]/g, '').split(',').map(coord => parseFloat(coord.trim()));
                if (!isNaN(x) && !isNaN(y)) {
                    joints.push([x, y]);
                }
            } else {
                // Analizar y agregar beams
                const [start, end] = line.split(' to ').map(part => part.replace(/[()]/g, '').split(',').map(coord => parseFloat(coord.trim())));
                if (start.length === 2 && end.length === 2) {
                    beams.push({ start, end });
                }
            }
        }
    });

    return { joints, beams };
}

// Función para pegar la información del portapapeles y reconstruir el puente
function pasteBridge() {
    const data = prompt("Paste the coords of the bridge: ");
    if (data) {
        const { joints, beams } = parseBridge(data);

        // Primero, limpia los joints y beams actuales del modelo
        bridgeModel.joints = [];
        bridgeModel.beams = [];

        // Añadir joints y beams al modelo usando las funciones 
        const jointMap = new Map();
        joints.forEach(position => {
            const joint = addJoint(position);
            jointMap.set(position.toString(), joint);
        });

        beams.forEach(({ start, end }) => {
            const jointA = jointMap.get(start.toString());
            const jointB = jointMap.get(end.toString());
            if (jointA && jointB) {
                addBeam(jointA, jointB);
            }
        });

        render();
    }
}


